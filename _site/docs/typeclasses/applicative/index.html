<h2 id="applicative">Applicative</h2>

<p>The <code class="highlighter-rouge">Applicative</code> typeclass abstracts the ability to lift values and apply functions over the computational context of a type constructor.
Examples of type constructors that can implement instances of the Applicative typeclass include <code class="highlighter-rouge">Option</code>, <code class="highlighter-rouge">NonEmptyList</code>,
<code class="highlighter-rouge">List</code> and many other datatypes that include a <code class="highlighter-rouge">just</code> and either <code class="highlighter-rouge">ap</code> function. <code class="highlighter-rouge">ap</code> may be derived for monadic types that include a <code class="highlighter-rouge">Monad</code> instance via <code class="highlighter-rouge">flatMap</code>.</p>

<p><code class="highlighter-rouge">Applicative</code> includes all combinators present in <a href="/docs/typeclasses/functor/"><code class="highlighter-rouge">Functor</code></a>.</p>

<h3 id="applicative-builder-examples">Applicative Builder examples</h3>

<p>Often times we find ourselves in situations where we need to compute multiple independent values resulting from operations that do not depend on each other.</p>

<p>In the following example we will define 3 invocations that may as well be remote or local services each one of them returning different results in the same computational context of <code class="highlighter-rouge">Option</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>
<span class="k">import</span> <span class="nn">arrow.core.*</span>

<span class="k">fun</span> <span class="n">profileService</span><span class="p">():</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Some</span><span class="p">(</span><span class="s">"Alfredo Lambda"</span><span class="p">)</span>
<span class="k">fun</span> <span class="n">phoneService</span><span class="p">():</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Some</span><span class="p">(</span><span class="m">55555555</span><span class="p">)</span>
<span class="k">fun</span> <span class="n">addressService</span><span class="p">():</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">=</span> <span class="n">Some</span><span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="s">"1 Main Street"</span><span class="p">,</span> <span class="s">"11130"</span><span class="p">,</span> <span class="s">"NYC"</span><span class="p">))</span>
</code></pre></div></div>

<p>This more or less illustrate the common use case of performing several independent operations where we need to get all the results together</p>

<p>The typeclass features several methods related to <a href="/docs/patterns/applicative_builder">Applicative Builders</a> that allow you to easily combine all the independent operations into one result.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">data class</span> <span class="nc">Profile</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">phone</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="kd">val</span> <span class="py">address</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span>

<span class="kd">val</span> <span class="py">r</span><span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Tuple3</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;&gt;</span> <span class="p">=</span> <span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">tupled</span><span class="p">(</span><span class="n">profileService</span><span class="p">(),</span> <span class="n">phoneService</span><span class="p">(),</span> <span class="n">addressService</span><span class="p">()).</span><span class="n">fix</span><span class="p">()</span>
<span class="n">r</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">Profile</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">c</span><span class="p">)</span> <span class="p">}</span>
<span class="c1">// Some(Profile(name=Alfredo Lambda, phone=55555555, address=[1 Main Street, 11130, NYC]))</span>
</code></pre></div></div>

<p>The Applicative Builder also provides a <code class="highlighter-rouge">map</code> operations that is able to abstract over arity in the same way as <code class="highlighter-rouge">tupled</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">profileService</span><span class="p">(),</span> <span class="n">phoneService</span><span class="p">(),</span> <span class="n">addressService</span><span class="p">(),</span> <span class="p">{</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">phone</span><span class="p">,</span> <span class="n">addresses</span><span class="p">)</span> <span class="p">-&gt;</span>
  <span class="n">Profile</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">phone</span><span class="p">,</span> <span class="n">addresses</span><span class="p">)</span>
<span class="p">})</span>
<span class="c1">// Some(Profile(name=Alfredo Lambda, phone=55555555, address=[1 Main Street, 11130, NYC]))</span>
</code></pre></div></div>

<h3 id="main-combinators">Main Combinators</h3>

<h4 id="just">just</h4>

<p>A constructor function, also known as <code class="highlighter-rouge">pure</code> in other languages.
It lifts a value into the computational context of a type constructor.</p>

<p><code class="highlighter-rouge">fun &lt;A&gt; just(a: A): Kind&lt;F, A&gt;</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Option</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="c1">// Some(1)</span>
<span class="c1">// Some(1)</span>
</code></pre></div></div>

<h4 id="kindf-aap">Kind&lt;F, A&gt;#ap</h4>

<p>Apply a function inside the type constructorâ€™s context</p>

<p><code class="highlighter-rouge">fun &lt;A, B&gt; Kind&lt;F, A&gt;.ap(ff: Kind&lt;F, (A) -&gt; B&gt;): Kind&lt;F, B&gt;</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span> <span class="n">Some</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">ap</span><span class="p">(</span><span class="n">Some</span><span class="p">({</span> <span class="n">n</span><span class="p">:</span> <span class="n">Int</span> <span class="p">-&gt;</span> <span class="n">n</span> <span class="p">+</span> <span class="m">1</span> <span class="p">}))</span> <span class="p">}</span>
<span class="c1">// Some(2)</span>
</code></pre></div></div>

<h4 id="other-combinators">Other combinators</h4>

<p>For a full list of other useful combinators available in <code class="highlighter-rouge">Applicative</code> see the <a href="https://github.com/arrow-kt/arrow/blob/master/arrow-data/src/main/kotlin/arrow/typeclasses/Applicative.kt" target="_blank">Source</a></p>

<h4 id="kindf-amap2">Kind&lt;F, A&gt;#map2</h4>

<p>Map 2 values inside the type constructor context and apply a function to their cartesian product</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span> <span class="n">Some</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">map2</span><span class="p">(</span><span class="n">Some</span><span class="p">(</span><span class="s">"x"</span><span class="p">))</span> <span class="p">{</span> <span class="n">z</span><span class="p">:</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;</span> <span class="p">-&gt;</span>  <span class="s">"${z.a}${z.b}"</span> <span class="p">}</span> <span class="p">}</span>
<span class="c1">// Some(1x)</span>
</code></pre></div></div>

<h4 id="kindf-amap2eval">Kind&lt;F, A&gt;#map2Eval</h4>

<p>Lazily map 2 values inside the type constructor context and apply a function to their cartesian product.
Computation happens when <code class="highlighter-rouge">.value()</code> is invoked.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span> <span class="n">Some</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">map2Eval</span><span class="p">(</span><span class="n">Eval</span><span class="p">.</span><span class="n">later</span> <span class="p">{</span> <span class="n">Some</span><span class="p">(</span><span class="s">"x"</span><span class="p">)</span> <span class="p">},</span> <span class="p">{</span> <span class="n">z</span><span class="p">:</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;</span> <span class="p">-&gt;</span>  <span class="s">"${z.a}${z.b}"</span> <span class="p">}).</span><span class="n">value</span><span class="p">()</span> <span class="p">}</span>
<span class="c1">// Some(1x)</span>
</code></pre></div></div>

<h3 id="laws">Laws</h3>

<p>Arrow provides <a href="https://github.com/arrow-kt/arrow/blob/master/arrow-test/src/main/kotlin/arrow/laws/ApplicativeLaws.kt" target="_blank"><code class="highlighter-rouge">ApplicativeLaws</code></a> in the form of test cases for internal verification of lawful instances and third party apps creating their own Applicative instances.</p>

<h4 id="creating-your-own-applicative-instances">Creating your own <code class="highlighter-rouge">Applicative</code> instances</h4>

<p>Arrow already provides Applicative instances for most common datatypes both in Arrow and the Kotlin stdlib.</p>

<p>See <a href="/docs/patterns/glossary">Deriving and creating custom typeclass</a> to provide your own Applicative instances for custom datatypes.</p>

<h3 id="data-types">Data Types</h3>

<p>The following datatypes in Arrow provide instances that adhere to the <code class="highlighter-rouge">Applicative</code> typeclass.</p>

<ul>
  <li><a href="/docs/datatypes/either">Either</a></li>
  <li><a href="/docs/datatypes/eithert">EitherT</a></li>
  <li><a href="/docs/datatypes/freeapplicative">FreeApplicative</a></li>
  <li><a href="/docs/datatypes/function1">Function1</a></li>
  <li><a href="/docs/datatypes/ior">Ior</a></li>
  <li><a href="/docs/datatypes/kleisli">Kleisli</a></li>
  <li><a href="/docs/datatypes/optiont">OptionT</a></li>
  <li><a href="/docs/datatypes/statet">StateT</a></li>
  <li><a href="/docs/datatypes/validated">Validated</a></li>
  <li><a href="/docs/datatypes/writert">WriterT</a></li>
  <li><a href="/docs/datatypes/const">Const</a></li>
  <li><a href="/docs/datatypes/try">Try</a></li>
  <li><a href="/docs/datatypes/eval">Eval</a></li>
  <li><a href="/docs/effects/io">IO</a></li>
  <li><a href="/docs/datatypes/nonemptylist">NonEmptyList</a></li>
  <li><a href="/docs/datatypes/id">Id</a></li>
  <li><a href="/docs/datatypes/function0">Function0</a></li>
</ul>

<p>Additionally all instances of <a href="/docs/typeclasses/monad"><code class="highlighter-rouge">Monad</code></a> and their MTL variants implement the <code class="highlighter-rouge">Applicative</code> typeclass directly
since they are all subtypes of <code class="highlighter-rouge">Applicative</code>.</p>

