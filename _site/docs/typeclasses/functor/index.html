<h2 id="functor">Functor</h2>

<p>The <code class="highlighter-rouge">Functor</code> typeclass abstracts the ability to <code class="highlighter-rouge">map</code> over the computational context of a type constructor.
Examples of type constructors that can implement instances of the Functor typeclass include <code class="highlighter-rouge">Option</code>, <code class="highlighter-rouge">NonEmptyList</code>,
<code class="highlighter-rouge">List</code> and many other datatypes that include a <code class="highlighter-rouge">map</code> function with the shape <code class="highlighter-rouge">fun F&lt;B&gt;.map(f: (A) -&gt; B): F&lt;B&gt;</code> where <code class="highlighter-rouge">F</code>
refers to <code class="highlighter-rouge">Option</code>, <code class="highlighter-rouge">List</code> or any other type constructor whose contents can be transformed.</p>

<h3 id="example">Example</h3>

<p>Oftentimes we find ourselves in situations where we need to transform the contents of some datatype. <code class="highlighter-rouge">Functor#map</code> allows
us to safely compute over values under the assumption that theyâ€™ll be there returning the transformation encapsulated in the same context.</p>

<p>Consider both <code class="highlighter-rouge">Option</code> and <code class="highlighter-rouge">Try</code>:</p>

<p><code class="highlighter-rouge">Option&lt;A&gt;</code> allows us to model absence and has two possible states, <code class="highlighter-rouge">Some(a: A)</code> if the value is not absent and <code class="highlighter-rouge">None</code> to represent an empty case.</p>

<p>In a similar fashion <code class="highlighter-rouge">Try&lt;A&gt;</code> may have two possible cases <code class="highlighter-rouge">Success(a: A)</code> for computations that succeed and <code class="highlighter-rouge">Failure(e: Throwable)</code> if they fail with an exception.</p>

<p>Both <code class="highlighter-rouge">Try</code> and <code class="highlighter-rouge">Option</code> are example datatypes that can be computed over transforming their inner results.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>
<span class="k">import</span> <span class="nn">arrow.core.*</span>
<span class="k">import</span> <span class="nn">arrow.data.*</span>

<span class="n">Try</span> <span class="p">{</span> <span class="s">"1"</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span> <span class="p">}.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="m">2</span> <span class="p">}</span>
<span class="n">Option</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="m">2</span> <span class="p">}</span>
<span class="c1">// Some(2)</span>
</code></pre></div></div>

<p>Both <code class="highlighter-rouge">Try</code> and <code class="highlighter-rouge">Option</code> include ready to use <code class="highlighter-rouge">Functor</code> instances:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">optionFunctor</span> <span class="p">=</span> <span class="n">Option</span><span class="p">.</span><span class="n">functor</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">tryFunctor</span> <span class="p">=</span> <span class="n">Try</span><span class="p">.</span><span class="n">functor</span><span class="p">()</span>
</code></pre></div></div>

<p>Mapping over the empty/failed cases is always safe since the <code class="highlighter-rouge">map</code> operation in both Try and Option operate under the bias of those containing success values</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">Try</span> <span class="p">{</span> <span class="s">"x"</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span> <span class="p">}.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="m">2</span> <span class="p">}</span>
<span class="n">none</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;().</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="m">2</span> <span class="p">}</span>
<span class="c1">// None</span>
</code></pre></div></div>

<h3 id="main-combinators">Main Combinators</h3>

<h4 id="kindf-amap">Kind&lt;F, A&gt;#map</h4>

<p>Transforms the inner contents</p>

<p><code class="highlighter-rouge">fun &lt;A, B&gt; Kind&lt;F, A&gt;.map(f: (A) -&gt; B): Kind&lt;F, B&gt;</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optionFunctor</span><span class="p">.</span><span class="n">run</span> <span class="p">{</span> <span class="n">Option</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">+</span> <span class="m">1</span> <span class="p">}</span> <span class="p">}</span>
<span class="c1">// Some(2)</span>
</code></pre></div></div>

<h4 id="lift">lift</h4>

<p>Lift a function to the Functor context so it can be applied over values of the implementing datatype</p>

<p><code class="highlighter-rouge">fun &lt;A, B&gt; lift(f: (A) -&gt; B): (Kind&lt;F, A&gt;) -&gt; Kind&lt;F, B&gt;</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">lifted</span> <span class="p">=</span> <span class="n">optionFunctor</span><span class="p">.</span><span class="n">lift</span><span class="p">({</span> <span class="n">n</span><span class="p">:</span> <span class="n">Int</span> <span class="p">-&gt;</span> <span class="n">n</span> <span class="p">+</span> <span class="m">1</span> <span class="p">})</span>
<span class="n">lifted</span><span class="p">(</span><span class="n">Option</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
<span class="c1">// Some(2)</span>
</code></pre></div></div>

<h4 id="other-combinators">Other combinators</h4>

<p>For a full list of other useful combinators available in <code class="highlighter-rouge">Functor</code> see the <a href="https://github.com/arrow-kt/arrow/blob/master/arrow-data/src/main/kotlin/arrow/typeclasses/Functor.kt" target="_blank">Source</a></p>

<h3 id="laws">Laws</h3>

<p>Arrow provides <a href="https://github.com/arrow-kt/arrow/blob/master/arrow-test/src/main/kotlin/arrow/laws/FunctorLaws.kt" target="_blank"><code class="highlighter-rouge">FunctorLaws</code></a> in the form of test cases for internal verification of lawful instances and third party apps creating their own Functor instances.</p>

<h4 id="creating-your-own-functor-instances">Creating your own <code class="highlighter-rouge">Functor</code> instances</h4>

<p>Arrow already provides Functor instances for most common datatypes both in Arrow and the Kotlin stdlib.
Oftentimes you may find the need to provide your own for unsupported datatypes.</p>

<p>You may create or automatically derive instances of functor for your own datatypes which you will be able to use in the context of abstract polymorfic code
as demonstrated in the <a href="#example">example</a> above.</p>

<p>See <a href="/docs/patterns/glossary">Deriving and creating custom typeclass</a></p>

<h3 id="data-types">Data Types</h3>

<p>The following datatypes in Arrow provide instances that adhere to the <code class="highlighter-rouge">Functor</code> typeclass.</p>

<ul>
  <li><a href="/docs/datatypes/cofree">Cofree</a></li>
  <li><a href="/docs/datatypes/coproduct">Coproduct</a></li>
  <li><a href="/docs/datatypes/coyoneda">Coyoneda</a></li>
  <li><a href="/docs/datatypes/either">Either</a></li>
  <li><a href="/docs/datatypes/eithert">EitherT</a></li>
  <li><a href="/docs/datatypes/freeapplicative">FreeApplicative</a></li>
  <li><a href="/docs/datatypes/function1">Function1</a></li>
  <li><a href="/docs/datatypes/ior">Ior</a></li>
  <li><a href="/docs/datatypes/kleisli">Kleisli</a></li>
  <li><a href="/docs/datatypes/optiont">OptionT</a></li>
  <li><a href="/docs/datatypes/statet">StateT</a></li>
  <li><a href="/docs/datatypes/validated">Validated</a></li>
  <li><a href="/docs/datatypes/writert">WriterT</a></li>
  <li><a href="/docs/datatypes/yoneda">Yoneda</a></li>
  <li><a href="/docs/datatypes/const">Const</a></li>
  <li><a href="/docs/datatypes/try">Try</a></li>
  <li><a href="/docs/datatypes/eval">Eval</a></li>
  <li><a href="/docs/effects/io">IO</a></li>
  <li><a href="/docs/datatypes/nonemptylist">NonEmptyList</a></li>
  <li><a href="/docs/datatypes/id">Id</a></li>
  <li><a href="/docs/datatypes/function0">Function0</a></li>
</ul>

<p>Additionally all instances of <a href="/docs/typeclasses/applicative"><code class="highlighter-rouge">Applicative</code></a>, <a href="/docs/typeclasses/monad"><code class="highlighter-rouge">Monad</code></a> and their MTL variants implement the <code class="highlighter-rouge">Functor</code> typeclass directly
since they are all subtypes of <code class="highlighter-rouge">Functor</code></p>

