<h2 id="typeclasses">Typeclasses</h2>

<p>Typeclasses define a set of functions associated to one generic type.
All methods inside a typeclass will have one of two shapes:</p>

<ul>
  <li>
    <p>Constructor: create a new <code class="highlighter-rouge">Kind&lt;F, A&gt;</code> from a value, a function, an error… Some examples are <code class="highlighter-rouge">just</code>, <code class="highlighter-rouge">raise</code>, <code class="highlighter-rouge">async</code>, <code class="highlighter-rouge">defer</code>, or <code class="highlighter-rouge">binding</code>.</p>
  </li>
  <li>
    <p>Extensions: add new functionality to a value <code class="highlighter-rouge">A</code> or a container <code class="highlighter-rouge">Kind&lt;F, A&gt;</code>, provided by an extension function. For example, <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">eqv</code>, <code class="highlighter-rouge">show</code>, <code class="highlighter-rouge">traverse</code>, <code class="highlighter-rouge">sequence</code>, or <code class="highlighter-rouge">combineAll</code>.</p>
  </li>
</ul>

<p>You can use typeclasses as a DSL to access new free functionality for an existing type,
or treat them as an abstraction placeholder for any one type that can implement the typeclass.
The extension functions are scoped within the typeclass so they do not pollute the global namespace!</p>

<p>What differentiates typeclasses from regular OOP inheritance is that typeclasses are meant to be implemented <em>outside</em> of their types.
The association is done using generic parametrization rather than subclassing by implementing the interface. This has multiple benefits:</p>

<ul>
  <li>You can treat typeclass implementations as stateless parameters because they’re just a collection of functions</li>
  <li>Typeclasses can be implemented for any class, even those not in the current project</li>
  <li>You can make available any one implementation of a typeclasses at any scope for the generic type they’re associated with by using functions like <code class="highlighter-rouge">run</code> and <code class="highlighter-rouge">with</code></li>
</ul>

<p>To assure that a typeclass has been correctly implemented for a type, Arrow provides a test suite called the “laws” per typeclass.
These test suites are available in the module <code class="highlighter-rouge">arrow-tests</code>.</p>

<h4 id="example">Example</h4>

<p>You can read all about how Arrow implements typeclasses in the <a href="/docs/patterns/glossary/">glossary</a>.
If you’d like to use typeclasses effectively in your client code you can head to the docs entry about <a href="/docs/patterns/dependency_injection">dependency injection</a>.</p>

<p>For this short example we will make available the scope of the typeclass <code class="highlighter-rouge">Eq</code> implemented for the type <code class="highlighter-rouge">String</code>, by using <code class="highlighter-rouge">run</code>.
This will make all the <code class="highlighter-rouge">Eq</code> extension functions, such as <code class="highlighter-rouge">eqv</code> and <code class="highlighter-rouge">neqv</code>, available inside the <code class="highlighter-rouge">run</code> block.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.instances.*</span>

<span class="kd">val</span> <span class="py">stringEq</span> <span class="p">=</span> <span class="n">String</span><span class="p">.</span><span class="n">eq</span><span class="p">()</span>

<span class="n">stringEq</span>
<span class="c1">// arrow.instances.StringKt$eq$1@37e04477</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stringEq</span><span class="p">.</span><span class="n">run</span> <span class="p">{</span>
  <span class="s">"1"</span><span class="p">.</span><span class="n">eqv</span><span class="p">(</span><span class="s">"2"</span><span class="p">)</span>
    <span class="p">&amp;&amp;</span> <span class="s">"2"</span><span class="p">.</span><span class="n">neqv</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// false</span>
</code></pre></div></div>

<h3 id="typeclasses-provided-by-arrow">Typeclasses provided by Arrow</h3>

<p>We will list all the typeclasses provided in Arrow grouped by the module they belong to, and a short description of the behavior they abstract.</p>

<h4 id="typeclasses-1">Typeclasses</h4>

<p>The package typeclasses contains all the typeclass definitions that are general enough not to be part of a specialized package.
We will list them by their hierarchy.</p>

<h5 id="general">General</h5>

<ul>
  <li>
    <p><a href="/docs/typeclasses/inject/"><code class="highlighter-rouge">Inject</code></a> - transformation between datatypes</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/alternative/"><code class="highlighter-rouge">Alternative</code></a> - has an structure that contains either of two values</p>
  </li>
</ul>

<h5 id="show">Show</h5>

<ul>
  <li><a href="/docs/typeclasses/show/"><code class="highlighter-rouge">Show</code></a> - literal representation of an object</li>
</ul>

<h5 id="eq">Eq</h5>

<ul>
  <li>
    <p><a href="/docs/typeclasses/eq/"><code class="highlighter-rouge">Eq</code></a> - structural equality between two objects</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/order/"><code class="highlighter-rouge">Order</code></a> -  determine whether one object precedes another</p>
  </li>
</ul>

<h5 id="semigroup">Semigroup</h5>

<ul>
  <li>
    <p><a href="/docs/typeclasses/semigroup/"><code class="highlighter-rouge">Semigroup</code></a> - can combine two objects together</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/semigroupk/"><code class="highlighter-rouge">SemigroupK</code></a> - can combine two datatypes together</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/monoid/"><code class="highlighter-rouge">Monoid</code></a> - combinable objects have an empty value</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/monoidk/"><code class="highlighter-rouge">MonoidK</code></a> - combinable datatypes have an empty value</p>
  </li>
</ul>

<h5 id="functor">Functor</h5>

<ul>
  <li>
    <p><a href="/docs/typeclasses/functor/"><code class="highlighter-rouge">Functor</code></a> - its contents can be mapped</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/applicative/"><code class="highlighter-rouge">Applicative</code></a> - independent execution</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/applicativeerror/"><code class="highlighter-rouge">ApplicativeError</code></a> - recover from errors in independent execution</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/monad/"><code class="highlighter-rouge">Monad</code></a> - sequential execution</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/monaderror/"><code class="highlighter-rouge">MonadError</code></a> - recover from errors in sequential execution</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/comonad/"><code class="highlighter-rouge">Comonad</code></a> - can extract values from it</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/bimonad/"><code class="highlighter-rouge">Bimonad</code></a> - both monad and comonad</p>
  </li>
</ul>

<h5 id="foldable">Foldable</h5>

<ul>
  <li>
    <p><a href="/docs/typeclasses/foldable/"><code class="highlighter-rouge">Foldable</code></a> - has a structure from which a value can be computed from visiting each element</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/bifoldable/"><code class="highlighter-rouge">Bifoldable</code></a> - same as foldable, but for structures with more than one possible type, like either</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/reducible/"><code class="highlighter-rouge">Reducible</code></a> - structures that can be combined to a summary value</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/traverse/"><code class="highlighter-rouge">Traverse</code></a> - has a structure for which each element can be visited and get applied an effect</p>
  </li>
</ul>

<h4 id="effects">Effects</h4>

<p>Effects provides a hierarchy of typeclasses for lazy and asynchronous execution.</p>

<ul>
  <li>
    <p><a href="/docs/effects/monaddefer/"><code class="highlighter-rouge">MonadDefer</code></a> - can evaluate functions lazily</p>
  </li>
  <li>
    <p><a href="/docs/effects/async/"><code class="highlighter-rouge">Async</code></a> - can be created using an asynchronous callback function</p>
  </li>
  <li>
    <p><a href="/docs/effects/effect/"><code class="highlighter-rouge">Effect</code></a> - can extract a value from an asynchronous function</p>
  </li>
</ul>

<h4 id="mtl">MTL</h4>

<p>The Monad Template Library module gives more specialized version of existing typeclasses</p>

<ul>
  <li>
    <p><a href="/docs/typeclasses/functorfilter/"><code class="highlighter-rouge">FunctorFilter</code></a> - can map values that pass a predicate</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/monadfilter/"><code class="highlighter-rouge">MonadFilter</code></a> - can sequentially execute values that pass a predicate</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/traversefilter/"><code class="highlighter-rouge">TraverseFilter</code></a> - can traverse values that pass a predicate</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/monadcombine/"><code class="highlighter-rouge">MonadCombine</code></a> - has a structure that can be combined and split for several datatypes</p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/monadwriter/"><code class="highlighter-rouge">MonadReader</code></a> - can implement the capabilities of the datatype <a href="/docs/datatypes/reader/"><code class="highlighter-rouge">Reader</code></a></p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/monadwriter/"><code class="highlighter-rouge">MonadWriter</code></a> - can implement the capabilities of the datatype <a href="/docs/datatypes/writert/"><code class="highlighter-rouge">Writer</code></a></p>
  </li>
  <li>
    <p><a href="/docs/typeclasses/monadstate/"><code class="highlighter-rouge">MonadState</code></a> - can implement the capabilities of the datatype <a href="/docs/datatypes/state/"><code class="highlighter-rouge">State</code></a></p>
  </li>
</ul>

<h4 id="optics">Optics</h4>

<ul>
  <li>
    <p><a href="/docs/optics/at/"><code class="highlighter-rouge">At</code></a> - provides a <a href="/docs/optics/lens/"><code class="highlighter-rouge">Lens</code></a> for a structure with an indexable focus</p>
  </li>
  <li>
    <p><a href="/docs/optics/filterindex/"><code class="highlighter-rouge">FilterIndex</code></a> - provides a <a href="/docs/optics/traversal/"><code class="highlighter-rouge">Traversal</code></a> for a structure with indexable foci that satisfy a predicate</p>
  </li>
  <li>
    <p><a href="/docs/optics/index/"><code class="highlighter-rouge">Index</code></a> - provides an <a href="/docs/optics/optional/"><code class="highlighter-rouge">Optional</code></a> for a structure with an indexable optional focus</p>
  </li>
  <li>
    <p><a href="/docs/optics/each/"><code class="highlighter-rouge">Each</code></a> - provides a <a href="/docs/optics/traversal/"><code class="highlighter-rouge">Traversal</code></a></p>
  </li>
</ul>

<h4 id="recursion">Recursion</h4>

<ul>
  <li>
    <p><a href="/docs/recursion/corecursive/"><code class="highlighter-rouge">Corecursive</code></a> - traverses a structure forwards from the starting case</p>
  </li>
  <li>
    <p><a href="/docs/recursion/recursive/"><code class="highlighter-rouge">Recursive</code></a> - traverses a structure backwards from the base case</p>
  </li>
  <li>
    <p><a href="/docs/recursion/birecursive/"><code class="highlighter-rouge">Birecursive</code></a> - it is both recursive and corecursive</p>
  </li>
</ul>
