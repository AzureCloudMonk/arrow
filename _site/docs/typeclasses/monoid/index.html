<h2 id="monoid">Monoid</h2>

<p><code class="highlighter-rouge">Monoid</code> extends the <code class="highlighter-rouge">Semigroup</code> type class, adding an <code class="highlighter-rouge">empty</code> method to semigroup’s <code class="highlighter-rouge">combine</code>. The empty method must return a value that when combined with any other instance of that type returns the other instance, i.e.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">combine</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span> <span class="p">==</span> <span class="n">combine</span><span class="p">(</span><span class="n">empty</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="p">==</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>For example, if we have a <code class="highlighter-rouge">Monoid&lt;String&gt;</code> with <code class="highlighter-rouge">combine</code> defined as string concatenation, then <code class="highlighter-rouge">empty = ""</code>.</p>

<p>Having an empty defined allows us to combine all the elements of some potentially empty collection of <code class="highlighter-rouge">T</code> for which a <code class="highlighter-rouge">Monoid&lt;T&gt;</code> is defined and return a <code class="highlighter-rouge">T</code>, rather than an <code class="highlighter-rouge">Option&lt;T&gt;</code> as we have a sensible default to fall back to.</p>

<p>And let’s see the instance of Monoid<String> in action.</String></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>
<span class="k">import</span> <span class="nn">arrow.instances.*</span>
<span class="k">import</span> <span class="nn">arrow.typeclasses.*</span>

<span class="n">String</span><span class="p">.</span><span class="n">monoid</span><span class="p">().</span><span class="n">empty</span><span class="p">()</span>
<span class="c1">// </span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span><span class="p">.</span><span class="n">monoid</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span> <span class="n">listOf</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;(</span><span class="s">"Λ"</span><span class="p">,</span> <span class="s">"R"</span><span class="p">,</span> <span class="s">"R"</span><span class="p">,</span> <span class="s">"O"</span><span class="p">,</span> <span class="s">"W"</span><span class="p">).</span><span class="n">combineAll</span><span class="p">()</span> <span class="p">}</span>
<span class="c1">// ΛRROW</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.core.*</span>

<span class="n">Option</span><span class="p">.</span><span class="n">monoid</span><span class="p">(</span><span class="n">Int</span><span class="p">.</span><span class="n">monoid</span><span class="p">()).</span><span class="n">run</span> <span class="p">{</span> <span class="n">listOf</span><span class="p">&lt;</span><span class="n">Option</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;&gt;(</span><span class="n">Some</span><span class="p">(</span><span class="m">1</span><span class="p">),</span> <span class="n">Some</span><span class="p">(</span><span class="m">1</span><span class="p">)).</span><span class="n">combineAll</span><span class="p">()</span> <span class="p">}</span>
<span class="c1">// Some(2)</span>
</code></pre></div></div>

<p>The advantage of using these type class provided methods, rather than the specific ones for each type, is that we can compose monoids to allow us to operate on more complex types, e.g.</p>

<p>This is also true if we define our own instances. As an example, let’s use <code class="highlighter-rouge">Foldable</code>’s <code class="highlighter-rouge">foldMap</code>, which maps over values accumulating the results, using the available <code class="highlighter-rouge">Monoid</code> for the type mapped onto.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.data.*</span>

<span class="n">ListK</span><span class="p">.</span><span class="n">foldable</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span> <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">).</span><span class="n">k</span><span class="p">().</span><span class="n">foldMap</span><span class="p">(</span><span class="n">Int</span><span class="p">.</span><span class="n">monoid</span><span class="p">(),</span> <span class="o">::</span><span class="n">identity</span><span class="p">)</span> <span class="p">}</span>
<span class="c1">// 15</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListK</span><span class="p">.</span><span class="n">foldable</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span> <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">).</span><span class="n">k</span><span class="p">().</span><span class="n">foldMap</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">monoid</span><span class="p">(),</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="p">})</span> <span class="p">}</span>
<span class="c1">// 12345</span>
</code></pre></div></div>

<p>To use this with a function that produces a tuple, we can define a Monoid for a tuple that will be valid for any tuple where the types it contains also have a Monoid available.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">monoidTuple</span><span class="p">(</span><span class="n">MA</span><span class="p">:</span> <span class="n">Monoid</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;,</span> <span class="n">MB</span><span class="p">:</span> <span class="n">Monoid</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;):</span> <span class="n">Monoid</span><span class="p">&lt;</span><span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
  <span class="k">object</span><span class="p">:</span> <span class="n">Monoid</span><span class="p">&lt;</span><span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;&gt;</span> <span class="p">{</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;.</span><span class="n">combine</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;):</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="p">{</span>
      <span class="kd">val</span> <span class="err">(</span><span class="py">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">)</span> <span class="p">=</span> <span class="k">this</span>
      <span class="kd">val</span> <span class="err">(</span><span class="py">ya</span><span class="p">,</span> <span class="n">yb</span><span class="p">)</span> <span class="p">=</span> <span class="n">y</span>
      <span class="k">return</span> <span class="n">Tuple2</span><span class="p">(</span><span class="n">MA</span><span class="p">.</span><span class="n">run</span> <span class="p">{</span> <span class="n">xa</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">ya</span><span class="p">)</span> <span class="p">},</span> <span class="n">MB</span><span class="p">.</span><span class="n">run</span> <span class="p">{</span> <span class="n">xb</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">yb</span><span class="p">)</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="n">empty</span><span class="p">():</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Tuple2</span><span class="p">(</span><span class="n">MA</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="n">MB</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>This way we are able to combine both values in one pass, hurrah!</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListK</span><span class="p">.</span><span class="n">foldable</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">M</span> <span class="p">=</span> <span class="n">monoidTuple</span><span class="p">(</span><span class="n">Int</span><span class="p">.</span><span class="n">monoid</span><span class="p">(),</span> <span class="n">String</span><span class="p">.</span><span class="n">monoid</span><span class="p">())</span>
  <span class="kd">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">).</span><span class="n">k</span><span class="p">()</span>

  <span class="n">list</span><span class="p">.</span><span class="n">foldMap</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="p">{</span> <span class="n">n</span><span class="p">:</span> <span class="n">Int</span> <span class="p">-&gt;</span>
   <span class="n">Tuple2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">.</span><span class="n">toString</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Tuple2(a=2, b=11)</span>
</code></pre></div></div>

<h3 id="data-types">Data Types</h3>

<p>The following data types in Arrow provide instances that adhere to the <code class="highlighter-rouge">Monoid</code> type class.</p>

<ul>
  <li><a href="/docs/datatypes/sequencek">SequenceK</a></li>
  <li><a href="/docs/datatypes/setk">SetK</a></li>
</ul>
