<h2 id="functional-error-handling">Functional Error Handling</h2>

<p>When dealing with errors in a purely functional way we try as much as we can to avoid exceptions.
Exceptions break referential transparency and lead to bugs when callers are unaware that they may happen until it’s too late at runtime.</p>

<p>In the following example we are going to model a basic program and go over the different options we have for dealing with errors in Arrow.
The program simulates the typical game scenario where we have to shoot a target and series of preconditions need to be met in order actually shot and hit it.</p>

<h3 id="requirements">Requirements</h3>

<ul>
  <li>Arm a Nuke launcher</li>
  <li>Aim toward a Target</li>
  <li>Launch a Nuke and impact the Target</li>
</ul>

<h3 id="requirements-1">Requirements</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** model */</span>
<span class="kd">object</span> <span class="nc">Nuke</span>
<span class="kd">object</span> <span class="nc">Target</span>
<span class="kd">object</span> <span class="nc">Impacted</span>

<span class="k">fun</span> <span class="n">arm</span><span class="p">():</span> <span class="n">Nuke</span> <span class="p">=</span> <span class="n">TODO</span><span class="p">()</span>
<span class="k">fun</span> <span class="n">aim</span><span class="p">():</span> <span class="n">Target</span> <span class="p">=</span> <span class="n">TODO</span><span class="p">()</span>
<span class="k">fun</span> <span class="n">launch</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="n">Target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">:</span> <span class="n">Nuke</span><span class="p">):</span> <span class="n">Impacted</span> <span class="p">=</span> <span class="n">TODO</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="exceptions">Exceptions</h3>

<p>A naive implementation that uses exceptions may look like this</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">arm</span><span class="p">():</span> <span class="n">Nuke</span> <span class="p">=</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"SystemOffline"</span><span class="p">)</span>
<span class="k">fun</span> <span class="n">aim</span><span class="p">():</span> <span class="n">Target</span> <span class="p">=</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"RotationNeedsOil"</span><span class="p">)</span>
<span class="k">fun</span> <span class="n">launch</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="n">Target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">:</span> <span class="n">Nuke</span><span class="p">):</span> <span class="n">Impacted</span> <span class="p">=</span> <span class="n">Impacted</span>
</code></pre></div></div>

<p>As you may have noticed the function signatures include no clue that when asking for <code class="highlighter-rouge">arm()</code> or <code class="highlighter-rouge">aim()</code>
an exception may be thrown.</p>

<h4 id="the-issues-with-exceptions">The issues with exceptions</h4>

<p>Exceptions can be seen as GOTO statement given they interrupt the program flow by jumping back to the caller.
Exceptions are not consistent as throwing an exception may not survive async boundaries, that is to say that one can’t rely on exceptions for error handling
in async code since invoking a function that is async inside a <code class="highlighter-rouge">try/catch</code> may not capture the exception potentially thrown in a different thread.</p>

<p>Because of this extreme power of stopping computation and jumping to other areas, Exceptions have been abused even in core libraries to signal events.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>at java.lang.Throwable.fillInStackTrace(Throwable.java:-1)
at java.lang.Throwable.fillInStackTrace(Throwable.java:782)
- locked &lt;0x6c&gt; (a sun.misc.CEStreamExhausted)
at java.lang.Throwable.&lt;init&gt;(Throwable.java:250)
at java.lang.Exception.&lt;init&gt;(Exception.java:54)
at java.io.IOException.&lt;init&gt;(IOException.java:47)
at sun.misc.CEStreamExhausted.&lt;init&gt;(CEStreamExhausted.java:30)
at sun.misc.BASE64Decoder.decodeAtom(BASE64Decoder.java:117)
at sun.misc.CharacterDecoder.decodeBuffer(CharacterDecoder.java:163)
at sun.misc.CharacterDecoder.decodeBuffer(CharacterDecoder.java:194)
</code></pre></div></div>

<p>They often lead to incorrect and dangerous code because <code class="highlighter-rouge">Throwable</code> is an open hierarchy where you may catch more than you originally intended to.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="p">{</span>
  <span class="n">doExceptionalStuff</span><span class="p">()</span> <span class="c1">//throws IllegalArgumentException</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">Throwable</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//too broad matches:</span>
    <span class="cm">/*
    VirtualMachineError
    OutOfMemoryError
    ThreadDeath
    LinkageError
    InterruptedException
    ControlThrowable
    NotImplementedError
    */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Furthermore exceptions are costly to create. <code class="highlighter-rouge">Throwable#fillInStackTrace</code> attempts to gather all stack information to present you with a meaningful stacktrace.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Throwable</span> <span class="o">{</span>
    <span class="cm">/**
    * Fills in the execution stack trace.
    * This method records within this Throwable object information
    * about the current state of the stack frames for the current thread.
    */</span>
    <span class="n">Throwable</span> <span class="nf">fillInStackTrace</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Constructing an exception may be as costly as your current Thread stack size and it’s also platform dependent since <code class="highlighter-rouge">fillInStackTrace</code> calls into native code.</p>

<p>More info in the cost of instantiating Throwables and throwing exceptions in generals can be found in the links below.</p>

<blockquote>
  <p><a href="http://normanmaurer.me/blog/2013/11/09/The-hidden-performance-costs-of-instantiating-Throwables/">The Hidden Performance costs of instantiating Throwables</a></p>
  <ul>
    <li>New: Creating a new Throwable each time</li>
    <li>Lazy: Reusing a created Throwable in the method invocation.</li>
    <li>Static: Reusing a static Throwable with an empty stacktrace.</li>
  </ul>
</blockquote>

<p>Exceptions may be considered generally a poor choice in Functional Programming when:</p>

<ul>
  <li>Modeling absence</li>
  <li>Modeling known business cases that result in alternate paths</li>
  <li>Used in async boundaries over unprincipled APIs (callbacks)</li>
  <li>In general when people have no access to your source code</li>
</ul>

<h3 id="how-do-we-model-exceptional-cases-then">How do we model exceptional cases then?</h3>

<p>Arrow provide proper datatypes and typeclasses to represent exceptional cases.</p>

<h3 id="option">Option</h3>

<p>We use <a href="/docs/datatypes/option"><code class="highlighter-rouge">Option</code></a> to model the potential absence of a value</p>

<p>When using <code class="highlighter-rouge">Option</code> our previous example may look like:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>
<span class="k">import</span> <span class="nn">arrow.core.*</span>

<span class="k">fun</span> <span class="n">arm</span><span class="p">():</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Nuke</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">None</span>
<span class="k">fun</span> <span class="n">aim</span><span class="p">():</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Target</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">None</span>
<span class="k">fun</span> <span class="n">launch</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="n">Target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">:</span> <span class="n">Nuke</span><span class="p">):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Impacted</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Some</span><span class="p">(</span><span class="n">Impacted</span><span class="p">)</span>
</code></pre></div></div>

<p>It’s easy to work with <a href="/docs/datatypes/option"><code class="highlighter-rouge">Option</code></a> if your lang supports <a href="/docs/patterns/monad_comprehensions">Monad Comprehensions</a> or special syntax for them.
Arrow provides <a href="/docs/patterns/monad_comprehensions">monadic comprehensions</a>  for all datatypes for which a <a href="/docs/typeclasses/monad"><code class="highlighter-rouge">Monad</code></a> instance exists built atop coroutines.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.typeclasses.*</span>

<span class="k">fun</span> <span class="n">attackOption</span><span class="p">():</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Impacted</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">Option</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">nuke</span> <span class="p">=</span> <span class="n">arm</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">target</span> <span class="p">=</span> <span class="n">aim</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">impact</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">impact</span>
  <span class="p">}.</span><span class="n">fix</span><span class="p">()</span>

<span class="n">attackOption</span><span class="p">()</span>
<span class="c1">//None</span>
</code></pre></div></div>

<p>While we could model this problem using <code class="highlighter-rouge">Option</code> and forgetting about exceptions we are still unable to determine the reasons why <code class="highlighter-rouge">arm()</code> and <code class="highlighter-rouge">aim()</code> returned empty values in the form of <code class="highlighter-rouge">None</code>.
For this reason using <code class="highlighter-rouge">Option</code> is only a good idea when we know that values may be absent but we don’t really care about the reason why.
Additionally <code class="highlighter-rouge">Option</code> is unable to capture exceptions so if an exception was thrown internally it would still bubble up and result in a runtime exception.</p>

<p>In the next example we are going to use <code class="highlighter-rouge">Try</code> to deal with potentially thrown exceptions that are outside the control of the caller.</p>

<h3 id="try">Try</h3>

<p>We use <a href="/docs/datatypes/try"><code class="highlighter-rouge">Try</code></a> when we want to be defensive about a computation that may fail with a runtime exception</p>

<p>How would our example look like implemented with <code class="highlighter-rouge">Try</code>?</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">fun</span> <span class="n">arm</span><span class="p">():</span> <span class="n">Try</span><span class="p">&lt;</span><span class="n">Nuke</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">Try</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"SystemOffline"</span><span class="p">)</span> <span class="p">}</span>

<span class="k">fun</span> <span class="n">aim</span><span class="p">():</span> <span class="n">Try</span><span class="p">&lt;</span><span class="n">Target</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">Try</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"RotationNeedsOil"</span><span class="p">)</span> <span class="p">}</span>

<span class="k">fun</span> <span class="n">launch</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="n">Target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">:</span> <span class="n">Nuke</span><span class="p">):</span> <span class="n">Try</span><span class="p">&lt;</span><span class="n">Impacted</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">Try</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"MissedByMeters"</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>As you can see by the examples below exceptions are now controlled and caught inside of a <code class="highlighter-rouge">Try</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arm</span><span class="p">()</span>
<span class="c1">// Failure(exception=java.lang.RuntimeException: SystemOffline)</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aim</span><span class="p">()</span>
<span class="c1">// Failure(exception=java.lang.RuntimeException: RotationNeedsOil)</span>
</code></pre></div></div>

<p>Unlike in the <code class="highlighter-rouge">Option</code> example here we can fold over the resulting value accessing the runtime exception.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">result</span> <span class="p">=</span> <span class="n">arm</span><span class="p">()</span>
<span class="n">result</span><span class="p">.</span><span class="n">fold</span><span class="p">({</span> <span class="n">ex</span> <span class="p">-&gt;</span> <span class="s">"BOOM!: $ex"</span><span class="p">},</span> <span class="p">{</span> <span class="s">"Got: $it"</span> <span class="p">})</span>
<span class="c1">// BOOM!: java.lang.RuntimeException: SystemOffline</span>
</code></pre></div></div>

<p>Just like it does for <code class="highlighter-rouge">Option</code>, Arrow also provides <code class="highlighter-rouge">Monad</code> instances for <code class="highlighter-rouge">Try</code> and we can use it exactly in the same way</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">attackTry</span><span class="p">():</span> <span class="n">Try</span><span class="p">&lt;</span><span class="n">Impacted</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">Try</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">nuke</span> <span class="p">=</span> <span class="n">arm</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">target</span> <span class="p">=</span> <span class="n">aim</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">impact</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">impact</span>
  <span class="p">}.</span><span class="n">fix</span><span class="p">()</span>

<span class="n">attackTry</span><span class="p">()</span>
<span class="c1">//Failure(RuntimeException("SystemOffline"))</span>
</code></pre></div></div>

<p>While <code class="highlighter-rouge">Try</code> gives us the ability to control both the <code class="highlighter-rouge">Success</code> and <code class="highlighter-rouge">Failure</code> cases there is still nothing in the function signatures that indicate the type of exception.
We are still subject to guess what the exception is using Kotlin <code class="highlighter-rouge">when</code> expressions or runtime lookups over the unsealed hierarchy of Throwable.</p>

<p>It turns out that all exceptions thrown in our example are actually known to the system so there is no point in modeling these exceptional cases as
<code class="highlighter-rouge">java.lang.Exception</code></p>

<p>We should redefine our functions to express that their result is not just a <code class="highlighter-rouge">Nuke</code>, <code class="highlighter-rouge">Target</code> or <code class="highlighter-rouge">Impact</code> but those potential values or other exceptional ones.</p>

<h3 id="either">Either</h3>

<p>When dealing with a known alternate path we model return types as <a href="/docs/datatypes/either"><code class="highlighter-rouge">Either</code></a>
Either represents the presence of either a <code class="highlighter-rouge">Left</code> value or a <code class="highlighter-rouge">Right</code> value.
By convention most functional programing libraries choose <code class="highlighter-rouge">Left</code> as the exceptional case and <code class="highlighter-rouge">Right</code> as the success value.</p>

<p>We can now assign proper types and values to the exceptional cases.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="kd">class</span> <span class="nc">NukeException</span> <span class="p">{</span>
  <span class="kd">object</span> <span class="nc">SystemOffline</span><span class="p">:</span> <span class="n">NukeException</span><span class="p">()</span>
  <span class="kd">object</span> <span class="nc">RotationNeedsOil</span><span class="p">:</span> <span class="n">NukeException</span><span class="p">()</span>
  <span class="kd">data class</span> <span class="nc">MissedByMeters</span><span class="p">(</span><span class="kd">val</span> <span class="py">meters</span> <span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">NukeException</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">typealias</span> <span class="n">SystemOffline</span> <span class="p">=</span> <span class="n">NukeException</span><span class="p">.</span><span class="n">SystemOffline</span>
<span class="k">typealias</span> <span class="n">RotationNeedsOil</span> <span class="p">=</span> <span class="n">NukeException</span><span class="p">.</span><span class="n">RotationNeedsOil</span>
<span class="k">typealias</span> <span class="n">MissedByMeters</span> <span class="p">=</span> <span class="n">NukeException</span><span class="p">.</span><span class="n">MissedByMeters</span>
</code></pre></div></div>

<p>This type of definition is commonly known as an Algebraic Data Type or Sum Type in most FP capable languages.
In Kotlin it is encoded using sealed hierarchies. We can think of sealed hierarchies as a declaration of a type and all it’
s possible states.</p>

<p>Once we have an ADT defined to model our known errors we can redefine our functions.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">arm</span><span class="p">():</span> <span class="n">Either</span><span class="p">&lt;</span><span class="n">SystemOffline</span><span class="p">,</span> <span class="n">Nuke</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Right</span><span class="p">(</span><span class="n">Nuke</span><span class="p">)</span>
<span class="k">fun</span> <span class="n">aim</span><span class="p">():</span> <span class="n">Either</span><span class="p">&lt;</span><span class="n">RotationNeedsOil</span><span class="p">,</span> <span class="n">Target</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Right</span><span class="p">(</span><span class="n">Target</span><span class="p">)</span>
<span class="k">fun</span> <span class="n">launch</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="n">Target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">:</span> <span class="n">Nuke</span><span class="p">):</span> <span class="n">Either</span><span class="p">&lt;</span><span class="n">MissedByMeters</span><span class="p">,</span> <span class="n">Impacted</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Left</span><span class="p">(</span><span class="n">MissedByMeters</span><span class="p">(</span><span class="m">5</span><span class="p">))</span>
</code></pre></div></div>

<p>Arrow also provides a <code class="highlighter-rouge">Monad</code> instance for <code class="highlighter-rouge">Either</code> in the same it did for <code class="highlighter-rouge">Option</code> and <code class="highlighter-rouge">Try</code>.
Except for the types signatures our program remains unchanged when we compute over <code class="highlighter-rouge">Either</code>.
All values on the left side assume to be <code class="highlighter-rouge">Right</code> biased and whenever a <code class="highlighter-rouge">Left</code> value is found the computation short-circuits producing a result that is compatible with the function type signature.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">attackEither</span><span class="p">():</span> <span class="n">Either</span><span class="p">&lt;</span><span class="n">NukeException</span><span class="p">,</span> <span class="n">Impacted</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">Either</span><span class="p">.</span><span class="n">monad</span><span class="p">&lt;</span><span class="n">NukeException</span><span class="p">&gt;().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">nuke</span> <span class="p">=</span> <span class="n">arm</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">target</span> <span class="p">=</span> <span class="n">aim</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">impact</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">impact</span>
  <span class="p">}.</span><span class="n">fix</span><span class="p">()</span>

<span class="n">attackEither</span><span class="p">()</span>
<span class="c1">//Left(MissedByMeters(5))</span>
</code></pre></div></div>

<p>We have seen so far how we can use <code class="highlighter-rouge">Option</code>, <code class="highlighter-rouge">Try</code> and <code class="highlighter-rouge">Either</code> to handle exceptions in a purely functional way.</p>

<p>The question now is, can we further generalize error handling and write this code in a way that is abstract from the actual datatypes that it uses.
Since Arrow supports typeclasses, emulated higher kinds and higher order abstractions we can rewrite this in a fully polymorphic way thanks to <a href="/docs/typeclasses/monaderror"><code class="highlighter-rouge">MonadError</code></a></p>

<h3 id="monaderror">MonadError</h3>

<p><a href="/docs/typeclasses/monaderror"><code class="highlighter-rouge">MonadError</code></a> is a typeclass that allows us to handle error cases inside monadic contexts such as the ones we have seen with <code class="highlighter-rouge">Either</code>, <code class="highlighter-rouge">Try</code> and <code class="highlighter-rouge">Option</code>.
Typeclasses allows us to code focusing on the behaviors and not the datatypes that implements them.</p>

<p>Arrow provides the following <code class="highlighter-rouge">MonadError</code> instances for <code class="highlighter-rouge">Option</code>, <code class="highlighter-rouge">Try</code> and <code class="highlighter-rouge">Either</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.typeclasses.*</span>

<span class="n">Option</span><span class="p">.</span><span class="n">monadError</span><span class="p">()</span>
<span class="c1">// arrow.core.Instance_arrow_instances_OptionMonadErrorInstanceKt$monadError$1@57f2f4d0</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Try</span><span class="p">.</span><span class="n">monadError</span><span class="p">()</span>
<span class="c1">// arrow.core.Instance_arrow_instances_TryMonadErrorInstanceKt$monadError$1@3cc78f08</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Either</span><span class="p">.</span><span class="n">monadError</span><span class="p">&lt;</span><span class="n">NukeException</span><span class="p">&gt;()</span>
<span class="c1">// arrow.core.Instance_arrow_instances_EitherMonadErrorInstanceKt$monadError$1@46e5fb01</span>
</code></pre></div></div>

<p>Let’s now rewrite our program as a polymorphic function that will work over any datatype for which a <code class="highlighter-rouge">MonadError</code> instance exists.
Polymorphic code in Arrow is based on emulated <a href="/docs/patterns/polymorphicprograms"><code class="highlighter-rouge">Higher Kinds</code></a> as described in <a href="https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf">Lightweight higher-kinded polymorphism</a> and applied to Kotlin, a lang which does not yet support Higher Kinded Types.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">f</span><span class="p">&gt;</span> <span class="n">arm</span><span class="p">(</span><span class="n">ME</span><span class="p">:</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">NukeException</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Nuke</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">ME</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="n">Nuke</span><span class="p">)</span>
<span class="k">fun</span> <span class="p">&lt;</span><span class="n">f</span><span class="p">&gt;</span> <span class="n">aim</span><span class="p">(</span><span class="n">ME</span><span class="p">:</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">NukeException</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Target</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">ME</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="n">Target</span><span class="p">)</span>
<span class="k">fun</span> <span class="p">&lt;</span><span class="n">f</span><span class="p">&gt;</span> <span class="n">launch</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="n">Target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">:</span> <span class="n">Nuke</span><span class="p">,</span> <span class="n">ME</span><span class="p">:</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">NukeException</span><span class="p">&gt;):</span>
  <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Impacted</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">ME</span><span class="p">.</span><span class="n">raiseError</span><span class="p">(</span><span class="n">MissedByMeters</span><span class="p">(</span><span class="m">5</span><span class="p">))</span>
</code></pre></div></div>

<p>We can now express the same program as before in a fully polymorphic context</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">f</span><span class="p">&gt;</span> <span class="n">attack</span><span class="p">(</span><span class="n">ME</span><span class="p">:</span><span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">NukeException</span><span class="p">&gt;):</span><span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Impacted</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">ME</span><span class="p">.</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">nuke</span> <span class="p">=</span> <span class="n">arm</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">target</span> <span class="p">=</span> <span class="n">aim</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">impact</span> <span class="p">=</span> <span class="n">launch</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;(</span><span class="n">target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">impact</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Or since <code class="highlighter-rouge">arm()</code> and <code class="highlighter-rouge">bind()</code> are operations that do not depend on each other we don’t need the <a href="/docs/patterns/monad_comprehensions">Monad Comprehensions</a> here and we can express our logic as:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">f</span><span class="p">&gt;</span> <span class="n">attack1</span><span class="p">(</span><span class="n">ME</span><span class="p">:</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">NukeException</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Impacted</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">ME</span><span class="p">.</span><span class="n">tupled</span><span class="p">(</span><span class="n">aim</span><span class="p">(),</span> <span class="n">arm</span><span class="p">()).</span><span class="n">flatMap</span><span class="p">(</span><span class="n">ME</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">nuke</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">launch</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;(</span><span class="n">nuke</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="p">})</span>

<span class="kd">val</span> <span class="py">result</span> <span class="p">=</span> <span class="n">attack</span><span class="p">&lt;</span><span class="n">EitherPartialOf</span><span class="p">&lt;</span><span class="n">NukeException</span><span class="p">&gt;&gt;()</span>
<span class="n">result</span><span class="p">.</span><span class="n">fix</span><span class="p">()</span>
<span class="c1">//Left(MissedByMeters(5))</span>
<span class="c1">// or</span>
<span class="kd">val</span> <span class="py">result1</span> <span class="p">=</span> <span class="n">attack</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monadError</span><span class="p">())</span>
<span class="n">result1</span><span class="p">.</span><span class="n">fix</span><span class="p">()</span>
</code></pre></div></div>

<p>Note that <code class="highlighter-rouge">MonadError</code> also has a function <code class="highlighter-rouge">bindingCatch</code> that automatically captures and wraps exceptions in its binding block.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">f</span><span class="p">&gt;</span> <span class="n">launchImjust</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="n">Target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">:</span> <span class="n">Nuke</span><span class="p">,</span> <span class="n">ME</span><span class="p">:</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">NukeException</span><span class="p">&gt;):</span> <span class="n">Impacted</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="n">MissedByMeters</span><span class="p">(</span><span class="m">5</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="p">&lt;</span><span class="n">f</span><span class="p">&gt;</span> <span class="n">attack</span><span class="p">(</span><span class="n">ME</span><span class="p">:</span><span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">NukeException</span><span class="p">&gt;):</span><span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Impacted</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">ME</span><span class="p">.</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">nuke</span> <span class="p">=</span> <span class="n">arm</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">target</span> <span class="p">=</span> <span class="n">aim</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">impact</span> <span class="p">=</span> <span class="n">launchImpure</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;(</span><span class="n">target</span><span class="p">,</span> <span class="n">nuke</span><span class="p">)</span>
    <span class="n">impact</span>
  <span class="p">}</span>
</code></pre></div></div>

<h3 id="credits">Credits</h3>

<p>Tutorial adapted from the 47 Degrees blog <a href="https://www.47deg.com/presentations/2017/02/18/Functional-error-handling/"><code class="highlighter-rouge">Functional Error Handling</code></a></p>

<p>Deck:</p>

<ul>
  <li>https://speakerdeck.com/raulraja/functional-error-handling</li>
  <li>https://github.com/47deg/functional-error-handling</li>
</ul>
