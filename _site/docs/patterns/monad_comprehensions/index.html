<h2 id="monad-comprehensions">Monad Comprehensions</h2>

<p>Monad comprehension is the name for a programming idiom available in multiple languages.
The purpose of monad comprehensions is to compose sequential chains of actions in a style that feels natural for programmers of all backgrounds.</p>

<h3 id="synchronous-sequences-of-actions">Synchronous sequences of actions</h3>

<p>A typical coding class starts teaching new programmers to think like an ideal computer. The computer is fed instructions one by one, and executed one after another.
The instructions modify the internal registers of this ideal computers to store and operate on values. As the values change over time, a result is returned and the program completes.</p>

<p>Let’s see one example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int number = 0;
number += 1;
print(number);
return number;
</code></pre></div></div>

<p>This style of programming is what’s usually called “imperative programming” after the fact of telling the computer what to do.
This style has grown over time over many programming languages with new paradigms, all with this underlying base.
It scaled during decades thanks to Moore’s law, where computer became faster and faster at alarming paces. At some point in the past decade, Moore’s law of vertical scaling plateaued near its theoretical limit.
Scaling started to become horizontal, with multiple cores working in parallel to achieve increasingly complex tasks.
This physical representation of cores became more apparent in software with the increase of multi-threading programs.</p>

<p>Mathematical laws for parallel programming have been known for decades, and applied in multiple languages.
They allow us to write sequenced code that can be run asynchronously over multiple threads, with assurances for completion.</p>

<h3 id="asynchronous-sequences-of-actions">Asynchronous sequences of actions</h3>

<p>The general representation of sequenced execution in code is called a <a href="/docs/typeclasses/monad"><code class="highlighter-rouge">Monad</code></a>. This typeclass is a short API for sequencing code, summarised in a single function <code class="highlighter-rouge">flatMap</code>.
It takes as a parameter one function to be called after the current operation completes, and that function has to return another <a href="/docs/typeclasses/monad"><code class="highlighter-rouge">Monad</code></a> to continue the operation with.
A common renaming of <code class="highlighter-rouge">flatMap</code> is <code class="highlighter-rouge">andThen</code>. Go to the documentation page to see a deep dive on the Monad API.</p>

<p>With knowledge of <code class="highlighter-rouge">flatMap</code> we can write sequential expressions that are ran asynchronously, even over multiple threads.
Implementations of <code class="highlighter-rouge">Monad</code> are available for internal types like <code class="highlighter-rouge">Try</code> and also integrations like <a href="/docs/integrations/rx2">RxJava 2</a> and <a href="/docs/integrations/kotlinxcoroutines">kotlinx.coroutines</a>. 
Let’s see one example using a <a href="/docs/typeclasses/monad"><code class="highlighter-rouge">Monad</code></a> called <a href="/docs/effects/io"><code class="highlighter-rouge">IO</code></a>, where we fetch from a database the information about the dean of university some student attends:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">university</span><span class="p">:</span> <span class="n">IO</span><span class="p">&lt;</span><span class="n">University</span><span class="p">&gt;</span> <span class="p">=</span> 
  <span class="n">getStudentFromDatabase</span><span class="p">(</span><span class="s">"Bob Roxx"</span><span class="p">).</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">student</span> <span class="p">-&gt;</span>
      <span class="n">getUniversityFromDatabase</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="n">universityId</span><span class="p">).</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">university</span> <span class="p">-&gt;</span>
        <span class="n">getDeanFromDatabase</span><span class="p">(</span><span class="n">university</span><span class="p">.</span><span class="n">deanId</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>The sequence of events is assured in that <code class="highlighter-rouge">getUniversityFromDatabase</code> will not be called until <code class="highlighter-rouge">getStudentFromDatabase</code> returns a result.
If <code class="highlighter-rouge">getStudentFromDatabase</code> fails, then <code class="highlighter-rouge">getUniversityFromDatabase</code> will never be called.
That same way, if <code class="highlighter-rouge">getUniversityFromDatabase</code> then <code class="highlighter-rouge">getDeanFromDatabase</code> will never be called. Error handling propagates through the chain.</p>

<p>While this coding style is an improvement for asynchrony, the readability for users accustomed to traditional imperative code suffers.
Computer science can bring us a construct to get the best of both styles.</p>

<h3 id="comprehensions-over-coroutines">Comprehensions over coroutines</h3>

<p>This feature is known with multiple names: async/await, coroutines, do notation, for comprehensions…each version contains certain unique points but all derive from the same principles.
In Kotlin, coroutines (introduced in version 1.1 of the language) make the compiler capable of rewriting seemingly synchronous code intro asynchronous sequences.
Arrow uses this capability of the compiler to bring you coroutines-like notation to all instances of the <a href="/docs/typeclasses/monad"><code class="highlighter-rouge">Monad</code></a> typeclass.</p>

<p>Every instance of <a href="/docs/typeclasses/monad"><code class="highlighter-rouge">Monad</code></a> contains a method <code class="highlighter-rouge">binding</code> that receives a suspended function as a parameter.
This functions must return the last element of the sequence of operations.
Let’s see a minimal example.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>
<span class="k">import</span> <span class="nn">arrow.effects.*</span>
<span class="k">import</span> <span class="nn">arrow.typeclasses.*</span>

<span class="n">IO</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
  <span class="m">1</span>
<span class="p">}.</span><span class="n">fix</span><span class="p">().</span><span class="n">unsafeRunSync</span><span class="p">()</span>
<span class="c1">// 1</span>
</code></pre></div></div>

<p>Anything in the function inside <code class="highlighter-rouge">binding</code> can be imperative and sequential code that’ll be executed when the data type decides.
In the case of <a href="/docs/effects/io"><code class="highlighter-rouge">IO</code></a>, it is immediately run blocking the current thread using <code class="highlighter-rouge">unsafeRunSync()</code>. Let’s expand the example by adding a second operation:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IO</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">IO</span><span class="p">.</span><span class="n">invoke</span> <span class="p">{</span> <span class="m">1</span> <span class="p">}</span>
  <span class="n">a</span> <span class="p">+</span> <span class="m">1</span>
<span class="p">}.</span><span class="n">fix</span><span class="p">().</span><span class="n">unsafeRunSync</span><span class="p">()</span>
<span class="c1">// Compiler error: the type of a is IO&lt;Int&gt;, cannot add 1 to it</span>
</code></pre></div></div>

<p>This is our first challenge. We’ve created an instance of <a href="/docs/effects/io"><code class="highlighter-rouge">IO</code></a> that’ll run a block asynchronously, and we cannot get the value from inside it.
From the previous snippet the first intuition would be to call <code class="highlighter-rouge">unsafeRunSync()</code> on <code class="highlighter-rouge">a</code> to get the value.
This will block the current thread until the operation completes. What we want is to, instead, run and await until <code class="highlighter-rouge">a</code> completes before yielding the result.
For that we have two flavors of the function <code class="highlighter-rouge">bind()</code>, which is a function only available inside the function passed to <code class="highlighter-rouge">binding()</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IO</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">IO</span><span class="p">.</span><span class="n">invoke</span> <span class="p">{</span> <span class="m">1</span> <span class="p">}.</span><span class="n">bind</span><span class="p">()</span>
  <span class="n">a</span> <span class="p">+</span> <span class="m">1</span>
<span class="p">}.</span><span class="n">fix</span><span class="p">().</span><span class="n">unsafeRunSync</span><span class="p">()</span>
<span class="c1">// 2</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IO</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">bind</span> <span class="p">{</span> <span class="n">IO</span><span class="p">.</span><span class="n">invoke</span> <span class="p">{</span> <span class="m">1</span> <span class="p">}</span> <span class="p">}</span>
  <span class="n">a</span> <span class="p">+</span> <span class="m">1</span>
<span class="p">}.</span><span class="n">fix</span><span class="p">().</span><span class="n">unsafeRunSync</span><span class="p">()</span>
<span class="c1">// 2</span>
</code></pre></div></div>

<p>What <code class="highlighter-rouge">bind()</code> does is use the rest of the sequential operations as the function you’d normally past to <code class="highlighter-rouge">flatMap</code>.
The equivalent code without using comprehensions would look like:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IO</span><span class="p">.</span><span class="n">invoke</span> <span class="p">{</span> <span class="m">1</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">result</span> <span class="p">-&gt;</span>
    <span class="n">IO</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="n">result</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">.</span><span class="n">fix</span><span class="p">().</span><span class="n">unsafeRunSync</span><span class="p">()</span>
<span class="c1">// 2</span>
</code></pre></div></div>

<p>With this new style we can rewrite our original example of database fetching as:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">university</span><span class="p">:</span> <span class="n">IO</span><span class="p">&lt;</span><span class="n">University</span><span class="p">&gt;</span> <span class="p">=</span> 
  <span class="n">IO</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">student</span> <span class="p">=</span> <span class="n">getStudentFromDatabase</span><span class="p">(</span><span class="s">"Bob Roxx"</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">university</span> <span class="p">=</span> <span class="n">getUniversityFromDatabase</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="n">universityId</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">dean</span> <span class="p">=</span> <span class="n">getDeanFromDatabase</span><span class="p">(</span><span class="n">university</span><span class="p">.</span><span class="n">deanId</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">dean</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>And you can still write your usual imperative code in the binding block, interleaved with code that returns instances of <a href="/docs/effects/io"><code class="highlighter-rouge">IO</code></a>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">getNLines</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">FilePath</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">IO</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">=</span> 
  <span class="n">IO</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">file</span> <span class="p">=</span> <span class="n">getFile</span><span class="p">(</span><span class="n">path</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">lines</span> <span class="p">=</span> <span class="n">file</span><span class="p">.</span><span class="n">readLines</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lines</span><span class="p">.</span><span class="n">length</span> <span class="p">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">IO</span><span class="p">.</span><span class="n">raiseError</span><span class="p">(</span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">"File has fewer lines than expected"</span><span class="p">)).</span><span class="n">bind</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">lines</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>While this looks like a great improvement to manually raise errors sometimes you will encounter unexpected behavior and exceptions in seemingly normal code.</p>

<h3 id="error-propagation-in-comprehensions">Error propagation in comprehensions</h3>

<p>While <a href="/docs/typeclasses/monad"><code class="highlighter-rouge">Monad</code></a> represents sequential code, it doesn’t account for an existing execution flow pattern: exceptions.
Exceptions work like old goto that can happen at any point during execution and stop the current block to jump to a catch block.</p>

<p>Let’s take a somewhat common mistake and expand on it:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">getLineLengthAverage</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">FilePath</span><span class="p">):</span> <span class="n">IO</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">=</span> 
  <span class="n">IO</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">file</span> <span class="p">=</span> <span class="n">getFile</span><span class="p">(</span><span class="n">path</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">lines</span> <span class="p">=</span> <span class="n">file</span><span class="p">.</span><span class="n">readLines</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">count</span> <span class="p">=</span> <span class="n">lines</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">length</span> <span class="p">}.</span><span class="n">foldLeft</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">acc</span><span class="p">,</span> <span class="n">lineLength</span> <span class="p">-&gt;</span> <span class="n">acc</span> <span class="p">+</span> <span class="n">lineLength</span> <span class="p">}</span>
    <span class="kd">val</span> <span class="py">average</span> <span class="p">=</span> <span class="n">count</span> <span class="p">/</span> <span class="n">lines</span><span class="p">.</span><span class="n">length</span>
    <span class="n">average</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>What would happen if the file contains 0 lines? The chain throws ArithmeticException with a division by 0!
This exception goes uncaught and finalizes the program with a crash. Knowing this it is obvious we can do better.</p>

<p>Our next approach can do automatic wrapping of unexpected exceptions to return them inside the operation sequence.
For this purpose, the typeclass <a href="/docs/typeclasses/monaderror"><code class="highlighter-rouge">MonadError</code></a> was created.
<a href="/docs/typeclasses/monaderror"><code class="highlighter-rouge">MonadError</code></a> allows us to raise and recover from errors.
It also contains a version of comprehensions that automatically wraps exceptions, called <code class="highlighter-rouge">bindingCatch</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">getLineLengthAverage</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">FilePath</span><span class="p">):</span> <span class="n">IO</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">=</span> 
  <span class="n">IO</span><span class="p">.</span><span class="n">monadError</span><span class="p">().</span><span class="n">bindingCatch</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">file</span> <span class="p">=</span> <span class="n">getFile</span><span class="p">(</span><span class="n">path</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">lines</span> <span class="p">=</span> <span class="n">file</span><span class="p">.</span><span class="n">readLines</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">count</span> <span class="p">=</span> <span class="n">lines</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">length</span> <span class="p">}.</span><span class="n">foldLeft</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">acc</span><span class="p">,</span> <span class="n">lineLength</span> <span class="p">-&gt;</span> <span class="n">acc</span> <span class="p">+</span> <span class="n">lineLength</span> <span class="p">}</span>
    <span class="kd">val</span> <span class="py">average</span> <span class="p">=</span> <span class="n">count</span> <span class="p">/</span> <span class="n">lines</span><span class="p">.</span><span class="n">length</span>
    <span class="n">average</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>With a small change we get handling of exceptions even within the binding block.
This wrapping works the same way as if we raised an error as the return from <code class="highlighter-rouge">getFile()</code> or <code class="highlighter-rouge">readLines()</code>, short-circuiting and stopping the sequence early.</p>

<p>Note that while most data types include an instance of <a href="/docs/typeclasses/monad"><code class="highlighter-rouge">Monad</code></a>, <a href="/docs/typeclasses/monaderror"><code class="highlighter-rouge">MonadError</code></a> is somewhat less common.</p>

<h3 id="what-about-those-threads">What about those threads?</h3>

<p>Arrow uses the same abstraction as coroutines to group threads and other contexts of execution: <code class="highlighter-rouge">CoroutineContext</code>.
There are multiple default values and wrappers for common cases in both the standard library, and the extension library <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-dispatcher/index.html">kotlinx.coroutines</a>.</p>

<p>In any <code class="highlighter-rouge">binding()</code> block there is a helper function <code class="highlighter-rouge">bindIn()</code> that takes a <code class="highlighter-rouge">CoroutineContext</code> as a parameter and can return any value.
This value will be lifted into a data type using <code class="highlighter-rouge">just()</code>.</p>

<p>The functions will cause a new coroutine to start on the <code class="highlighter-rouge">CoroutineContext</code> passed as a parameter to then <code class="highlighter-rouge">bind()</code> to await for its completion.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">ioThreadContext</span> <span class="p">=</span> <span class="n">newSingleThreadContext</span><span class="p">(</span><span class="s">"IO"</span><span class="p">)</span>
<span class="kd">val</span> <span class="py">computationThreadContext</span> <span class="p">=</span> <span class="n">newSingleThreadContext</span><span class="p">(</span><span class="s">"Computation"</span><span class="p">)</span>

<span class="k">fun</span> <span class="n">getLineLengthAverage</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">FilePath</span><span class="p">):</span> <span class="n">IO</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">=</span> 
  <span class="n">IO</span><span class="p">.</span><span class="n">monadError</span><span class="p">().</span><span class="n">bindingCatch</span> <span class="p">{</span>
    
    <span class="c1">// Implicitly wrap the result of a synchronous operation into IO.just() using bindIn</span>
    <span class="kd">val</span> <span class="py">file</span> <span class="p">=</span> <span class="n">bindIn</span><span class="p">(</span><span class="n">ioThreadContext</span><span class="p">)</span> <span class="p">{</span> <span class="n">getFile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">}</span>    
    <span class="kd">val</span> <span class="py">lines</span> <span class="p">=</span> <span class="n">bindIn</span><span class="p">(</span><span class="n">computationThreadContext</span><span class="p">)</span> <span class="p">{</span> <span class="n">file</span><span class="p">.</span><span class="n">readLines</span><span class="p">()</span> <span class="p">}</span>
    
    <span class="kd">val</span> <span class="py">count</span> <span class="p">=</span> <span class="n">lines</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">length</span> <span class="p">}.</span><span class="n">foldLeft</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">acc</span><span class="p">,</span> <span class="n">lineLength</span> <span class="p">-&gt;</span> <span class="n">acc</span> <span class="p">+</span> <span class="n">lineLength</span> <span class="p">}</span>
    <span class="kd">val</span> <span class="py">average</span> <span class="p">=</span> <span class="n">count</span> <span class="p">/</span> <span class="n">lines</span><span class="p">.</span><span class="n">length</span>
    <span class="n">average</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Note that <code class="highlighter-rouge">bindIn()</code>assures that the execution will return to the same thread where the binding started after the <code class="highlighter-rouge">bindIn</code> block executes.</p>

<p>There is also a version of <code class="highlighter-rouge">bindIn</code> called <code class="highlighter-rouge">bindDeferredIn</code> that allows deferred construction.
It’s available for <code class="highlighter-rouge">bindingCancellable</code> comprehensions over instances of <a href="/docs/effects/monaddefer"><code class="highlighter-rouge">MonadDefer</code></a>.</p>

<h3 id="what-if-id-like-to-run-multiple-operations-independently-from-each-other-in-a-non-sequential-way">What if I’d like to run multiple operations independently from each other, in a non-sequential way?</h3>

<p>You can check the section on the <a href="/docs/patterns/applicative_builder">Applicative Builder</a> pattern for them!</p>

<h3 id="cancellation-and-cleanup-of-resources">Cancellation and cleanup of resources</h3>

<p>In some environments that have resources with their own lifecycle (i.e. Activity in Android development) retaining these values in operations that can run indefinitely may cause large memory leaks and lead to undefined behavior.
As cleanup is important in these restricted environments, any instance of <a href="/docs/effects/monaddefer"><code class="highlighter-rouge">MonadDefer</code></a> provides the function <code class="highlighter-rouge">bindingCancellable</code>, which allows for comprehensions to be finished early by throwing an <code class="highlighter-rouge">BindingCancellationException</code> at the beginning of the next <code class="highlighter-rouge">bind()</code> step.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="err">(</span><span class="py">binding</span><span class="p">:</span> <span class="n">IO</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;&gt;,</span> <span class="n">unsafeCancel</span><span class="p">:</span> <span class="n">Disposable</span><span class="p">)</span> <span class="p">=</span>
  <span class="n">ioSync</span><span class="p">.</span><span class="n">bindingCancellable</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">userProfile</span> <span class="p">=</span> <span class="n">bindAsync</span><span class="p">(</span><span class="n">ioAsync</span><span class="p">)</span> <span class="p">{</span> <span class="n">getUserProfile</span><span class="p">(</span><span class="s">"123"</span><span class="p">)</span> <span class="p">}</span>
    <span class="kd">val</span> <span class="py">friendProfiles</span> <span class="p">=</span> <span class="n">userProfile</span><span class="p">.</span><span class="n">friends</span><span class="p">().</span><span class="n">map</span> <span class="p">{</span> <span class="n">friend</span> <span class="p">-&gt;</span>
        <span class="n">bindAsync</span><span class="p">(</span><span class="n">ioAsync</span><span class="p">)</span> <span class="p">{</span> <span class="n">getProfile</span><span class="p">(</span><span class="n">friend</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">listOf</span><span class="p">(</span><span class="n">userProfile</span><span class="p">)</span> <span class="p">+</span> <span class="n">friendProfiles</span>
  <span class="p">}</span>

<span class="n">binding</span><span class="p">.</span><span class="n">unsafeRunAsync</span> <span class="p">{</span> <span class="n">result</span> <span class="p">-&gt;</span>
  <span class="n">result</span><span class="p">.</span><span class="n">fold</span><span class="p">({</span> <span class="n">println</span><span class="p">(</span><span class="s">"Boom! caused by $it"</span><span class="p">)</span> <span class="p">},</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">toString</span><span class="p">())</span> <span class="p">})</span>
<span class="p">}</span>

<span class="n">unsafeCancel</span><span class="p">()</span>
<span class="c1">// Boom! caused by BindingCancellationException</span>
</code></pre></div></div>

<p>Note that the cancellation happens on the <code class="highlighter-rouge">bind()</code> step, so any currently running operations before <code class="highlighter-rouge">bind()</code> will have to complete first, even those that are scheduled for threading.</p>
