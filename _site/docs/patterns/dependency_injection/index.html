<p>If you would like to know about using the <a href="/docs/datatypes/reader"><code class="highlighter-rouge">Reader</code></a> datatype instead, visit <a href="https://medium.com/@JorgeCastilloPr/kotlin-dependency-injection-with-the-reader-monad-7d52f94a482e">this article</a> by <a href="https://github.com/JorgeCastilloPrz">Jorge Castillo</a>.</p>

<h2 id="dependency-injection-using-the-typeclassless-technique">Dependency Injection using the <code class="highlighter-rouge">Typeclassless</code> technique</h2>

<p>Arrow allows abstracting polymorphic code that operates over the evidence of having an instance of a <a href="/docs/typeclasses/intro">typeclass</a> available.
This enables programs that are not coupled to specific datatype implementations.
The technique demonstrated below to write polymorphic code is available for all other typeclasses besides <a href="/docs/typeclasses/functor"><code class="highlighter-rouge">Functor</code></a>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">multiplyBy2</span><span class="p">(</span><span class="n">FT</span><span class="p">:</span> <span class="n">Functor</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;,</span> <span class="n">fa</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="cm">/* ... */</span>

<span class="n">multiplyBy2</span><span class="p">(</span><span class="n">Option</span><span class="p">.</span><span class="n">functor</span><span class="p">(),</span> <span class="n">Option</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
<span class="c1">// Some(2)</span>

<span class="n">multiplyBy2</span><span class="p">(</span><span class="n">Try</span><span class="p">.</span><span class="n">functor</span><span class="p">(),</span> <span class="n">Try</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
<span class="c1">// Success(2)</span>
</code></pre></div></div>

<p>In the example above we’ve defined a function that can operate over any data type for which a <a href="/docs/typeclasses/functor"><code class="highlighter-rouge">Functor</code></a> instance is available.
And then we applied <code class="highlighter-rouge">multiplyBy2</code> to two different datatypes for which Functor instances exist.
This technique applied to other Typeclasses allows users to describe entire programs in terms of behaviors typeclasses removing
dependencies to concrete data types and how they operate.</p>

<p>This technique does not enforce inheritance or any kind of subtyping relationship and is frequently known as <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism"><code class="highlighter-rouge">ad-hoc polymorphism</code></a>
and frequently used in programming languages that support <a href="/docs/typeclasses/intro">typeclass</a> and <a href="/docs/patterns/glossary">typeclass</a>.</p>

<p>Entire libraries and applications can be written without enforcing consumers to use the lib author provided datatypes but letting
users provide their own provided there is typeclass instances for their datatypes.</p>

<p>Now, passing around a typeclass parameter like <code class="highlighter-rouge">Functor</code> to every function is repetitive, tedious, and error-prone. For that reason, many programming languages provide with a mechanism to describe the dependencies of the function without having to pass them as parameter explicitly. In Kotlin, this is achieved using extension functions.</p>

<h2 id="typeclasses-as-dependencies">Typeclasses as dependencies</h2>

<p>As described in the glossary, typeclasses are a grouping of constructors and extension functions on <code class="highlighter-rouge">Kind&lt;F, A&gt;</code> that form a DSL for the type they’re declared to. To access these extension functions you need to be in the scope of a typeclass. That is, the typeclass object has to be bound to <code class="highlighter-rouge">this</code>. Kotlin provides two ways of achieving this: with standard library functions, and with more extension functions.</p>

<h4 id="standard-library-functions">Standard library functions</h4>

<p>The function <code class="highlighter-rouge">multiplyBy2</code> as defined above receives <code class="highlighter-rouge">FT: Functor&lt;F&gt;</code> as a parameter. We need to bind <code class="highlighter-rouge">FT</code> to <code class="highlighter-rouge">this</code> to be able to access the extension function <code class="highlighter-rouge">fun &lt;A, B&gt; Kind&lt;F, A&gt;.map(f: (A) -&gt; B): Kind&lt;F, B&gt;</code> inside. For that we use the standard library function <code class="highlighter-rouge">typeclass.run { }</code>, which requires a value return.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">multiplyBy2</span><span class="p">(</span><span class="n">FT</span><span class="p">:</span> <span class="n">Functor</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;,</span> <span class="n">fa</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">FT</span><span class="p">.</span><span class="n">run</span> <span class="p">{</span> <span class="n">fa</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="m">2</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></div></div>

<p>If we have a block that does not return a value or <code class="highlighter-rouge">Unit</code>, I recommended to use either <code class="highlighter-rouge">with(typeclass) { }</code> to emphasize the difference.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">printAllValues</span><span class="p">(</span><span class="n">S</span><span class="p">:</span> <span class="n">Show</span><span class="p">&lt;</span><span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;&gt;,</span> <span class="n">fa</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;&gt;):</span> <span class="n">Unit</span> <span class="p">{</span>
  <span class="n">with</span> <span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fa</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">fa</span><span class="p">.</span><span class="n">show</span><span class="p">())</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="extension-functions">Extension functions</h4>

<p>An extension function is applied to a type, that becomes bound to <code class="highlighter-rouge">this</code> and enables calling all its functions without using <code class="highlighter-rouge">this.method()</code>. If we declare a function to depend on the typeclass, we get automatic access to the extension functions declared inside.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">Functor</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;.</span><span class="n">multiplyBy2</span><span class="p">(</span><span class="n">fa</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">fa</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="m">2</span> <span class="p">}</span>
</code></pre></div></div>

<p>And we can call it on the typeclass instances:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Option</span><span class="p">.</span><span class="n">functor</span><span class="p">().</span><span class="n">multiplyBy2</span><span class="p">(</span><span class="n">Try</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Try</span><span class="p">.</span><span class="n">functor</span><span class="p">().</span><span class="n">multiplyBy2</span><span class="p">(</span><span class="n">Try</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
</code></pre></div></div>

<p>The same applies to functions without a return value, so you don’t have to remember to use the right function.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">Show</span><span class="p">&lt;</span><span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;&gt;.</span><span class="n">printAllValues</span><span class="p">(</span><span class="n">fa</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;&gt;):</span> <span class="n">Unit</span> <span class="p">{</span>
  <span class="n">fa</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">fa</span><span class="p">.</span><span class="n">show</span><span class="p">())</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="declaring-typeclass-dependencies-on-client-code">Declaring typeclass dependencies on client code</h2>

<p>Knowing these two ways of accessing all the extension functions defined on a typeclass, how do we apply them to client code? This is heavily dependent on where Kotlin allows the use of extension functions. Let’s go through each case.</p>

<h3 id="scoped-functions">Scoped Functions</h3>

<p>Any function that exists inside an object, companion object, or in the root of a file, can be declared as an extension function on its typeclass parameters.
Extension functions declared for the same types can call into each other without passing the type parameter explicitly.</p>

<p>This is the simplest, most direct case, and that’s no coincidence. Most FP languages only allow functions scoped to global, a module, or an object that acts as a namespace.
Programs are composed by functions and tested on their typeclass and data parameters that define the functionality.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">Eq</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;.</span><span class="n">remove</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;,</span> <span class="n">a</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">l</span><span class="p">.</span><span class="n">filterNot</span> <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="n">eqv</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">object</span> <span class="nc">FunctorLaws</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">Functor</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;.</span><span class="n">test</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Law</span><span class="p">&gt;</span> <span class="p">=</span>
      <span class="n">listOf</span><span class="p">(</span>
        <span class="n">Law</span><span class="p">(</span><span class="s">"Functor Laws: Covariant Identity"</span><span class="p">,</span> <span class="p">{</span> <span class="n">covariantIdentity</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">}),</span>
        <span class="n">Law</span><span class="p">(</span><span class="s">"Functor Laws: Covariant Composition"</span><span class="p">,</span> <span class="p">{</span> <span class="n">covariantComposition</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">})</span>
      <span class="p">)</span>

  <span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">Functor</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;.</span><span class="n">covariantIdentityTest</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;):</span> <span class="n">Unit</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span>

  <span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">Functor</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;.</span><span class="n">covariantComposition</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;:</span> <span class="n">Unit</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>

<span class="o">..</span><span class="p">.</span>

<span class="k">import</span> <span class="nn">arrow.test.FunctorLaws.test</span>

<span class="n">Option</span><span class="p">.</span><span class="n">functor</span><span class="p">().</span><span class="n">test</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">some</span><span class="p">()</span> <span class="p">}</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Throwable</span><span class="p">&gt;.</span><span class="n">ankMonadErrorInterpreter</span><span class="p">():</span> <span class="n">FunctionK</span><span class="p">&lt;</span><span class="n">ForAnkOps</span><span class="p">,</span> <span class="n">F</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="kd">object</span> <span class="err">: </span><span class="nc">FunctionK</span><span class="p">&lt;</span><span class="n">ForAnkOps</span><span class="p">,</span> <span class="n">F</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">invoke</span><span class="p">(</span><span class="n">fa</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">ForAnkOps</span><span class="p">,</span> <span class="n">A</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="p">&gt;</span> <span class="p">{</span>
      <span class="kd">val</span> <span class="py">op</span> <span class="p">=</span> <span class="n">fa</span><span class="p">.</span><span class="n">ev</span><span class="p">()</span>
      <span class="k">return</span> <span class="k">when</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">is</span> <span class="n">AnkOps</span><span class="p">.</span><span class="n">CreateTarget</span> <span class="p">-&gt;</span> <span class="k">catch</span> <span class="p">{</span> <span class="n">createTargetImpl</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">source</span><span class="p">,</span> <span class="n">op</span><span class="p">.</span><span class="n">target</span><span class="p">)</span> <span class="p">}</span>
          <span class="k">is</span> <span class="n">AnkOps</span><span class="p">.</span><span class="n">GetFileCandidates</span> <span class="p">-&gt;</span> <span class="k">catch</span> <span class="p">{</span> <span class="n">getFileCandidatesImpl</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">target</span><span class="p">)</span> <span class="p">}</span>
          <span class="k">is</span> <span class="n">AnkOps</span><span class="p">.</span><span class="n">ReadFile</span> <span class="p">-&gt;</span> <span class="k">catch</span> <span class="p">{</span> <span class="n">readFileImpl</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">source</span><span class="p">)</span> <span class="p">}</span>
          <span class="k">is</span> <span class="n">AnkOps</span><span class="p">.</span><span class="n">ParseMarkdown</span> <span class="p">-&gt;</span> <span class="k">catch</span> <span class="p">{</span> <span class="n">parseMarkDownImpl</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">markdown</span><span class="p">)</span> <span class="p">}</span>
          <span class="k">is</span> <span class="n">AnkOps</span><span class="p">.</span><span class="n">ExtractCode</span> <span class="p">-&gt;</span> <span class="k">catch</span> <span class="p">{</span> <span class="n">extractCodeImpl</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">source</span><span class="p">,</span> <span class="n">op</span><span class="p">.</span><span class="n">tree</span><span class="p">)</span> <span class="p">}</span>
          <span class="k">is</span> <span class="n">AnkOps</span><span class="p">.</span><span class="n">CompileCode</span> <span class="p">-&gt;</span> <span class="k">catch</span> <span class="p">{</span> <span class="n">compileCodeImpl</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">snippets</span><span class="p">,</span> <span class="n">op</span><span class="p">.</span><span class="n">compilerArgs</span><span class="p">)</span> <span class="p">}</span>
          <span class="k">is</span> <span class="n">AnkOps</span><span class="p">.</span><span class="n">ReplaceAnkToLang</span> <span class="p">-&gt;</span> <span class="k">catch</span> <span class="p">{</span> <span class="n">replaceAnkToLangImpl</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">compilationResults</span><span class="p">)</span> <span class="p">}</span>
          <span class="k">is</span> <span class="n">AnkOps</span><span class="p">.</span><span class="n">GenerateFiles</span> <span class="p">-&gt;</span> <span class="k">catch</span> <span class="p">{</span> <span class="n">generateFilesImpl</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">candidates</span><span class="p">,</span> <span class="n">op</span><span class="p">.</span><span class="n">newContents</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<h3 id="classes">Classes</h3>

<p>As typeclasses are defined as interfaces in Kotlin, it’s trivial to convert any class you control into an implementer of a typeclass by using delegation.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">data class</span> <span class="nc">Parser</span><span class="p">:</span> <span class="n">Monad</span><span class="p">&lt;</span><span class="n">ForOption</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">Option</span><span class="p">.</span><span class="n">monad</span><span class="p">(),</span> <span class="n">Traverse</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">ListK</span><span class="p">.</span><span class="n">traverse</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="n">parseInt</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="n">parseOrThrow</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">just</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Throwable</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">none</span><span class="p">()</span>
    <span class="p">}</span>

  <span class="k">fun</span> <span class="n">parseInts</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
    <span class="n">l</span><span class="p">.</span><span class="n">k</span><span class="p">().</span><span class="n">traverse</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">parseInt</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span> <span class="p">}).</span><span class="n">fix</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">val</span> <span class="py">parser</span> <span class="p">=</span> <span class="n">Parser</span><span class="p">()</span>

<span class="n">parser</span><span class="p">.</span><span class="n">parseInts</span><span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="s">"1"</span><span class="p">.</span><span class="n">some</span><span class="p">(),</span> <span class="s">"2"</span><span class="p">.</span><span class="n">some</span><span class="p">()))</span>
<span class="c1">// Some([1, 2])</span>

<span class="n">parser</span><span class="p">.</span><span class="n">parseInts</span><span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="s">"bla"</span><span class="p">.</span><span class="n">some</span><span class="p">(),</span> <span class="s">"2"</span><span class="p">.</span><span class="n">some</span><span class="p">()))</span>
<span class="c1">// None</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">UserFetcher</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;(</span><span class="n">ME</span><span class="p">:</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Throwable</span><span class="p">&gt;,</span> <span class="kd">val</span> <span class="py">api</span><span class="p">:</span> <span class="n">ApiService</span><span class="p">):</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Throwable</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">ME</span> <span class="p">{</span>

  <span class="k">fun</span> <span class="n">getUserFriends</span><span class="p">(</span><span class="n">fid</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">UserId</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
    <span class="n">bindingCatch</span> <span class="p">{</span>
      <span class="kd">val</span> <span class="py">id</span> <span class="p">=</span> <span class="n">fid</span><span class="p">.</span><span class="n">bind</span><span class="p">()</span>
      <span class="kd">val</span> <span class="py">user</span> <span class="p">=</span> <span class="n">api</span><span class="p">.</span><span class="n">getUser</span><span class="p">(</span><span class="n">id</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
      <span class="n">user</span><span class="p">.</span><span class="n">friendIds</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">api</span><span class="p">.</span><span class="n">getUser</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}.</span><span class="n">bind</span><span class="p">()</span>
    <span class="p">}.</span><span class="n">handleError</span> <span class="p">{</span> <span class="n">listOf</span><span class="p">()</span> <span class="p">}</span>

  <span class="k">fun</span> <span class="n">createId</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">UserId</span><span class="p">&gt;</span> <span class="p">=</span>
    <span class="k">catch</span> <span class="p">{</span> <span class="n">parseIdOrThrow</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">UserId</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="o">..</span><span class="p">.</span>

<span class="kd">val</span> <span class="py">fetcher</span> <span class="p">=</span> <span class="n">UserFetcher</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monadError</span><span class="p">(),</span> <span class="n">ApiService</span><span class="p">())</span>

<span class="n">fetcher</span><span class="p">.</span><span class="n">getUserFriends</span><span class="p">(</span><span class="n">fetcher</span><span class="p">.</span><span class="n">createId</span><span class="p">(</span><span class="s">"122344"</span><span class="p">))</span>
<span class="c1">// Right([User(id="123", friendIds=["122344"]), User(id="44", friendIds=["122344", "1245"]), User(id="1245", friendIds=["122344", "44"])])])</span>
</code></pre></div></div>

<h3 id="methods-inside-a-class">Methods inside a class</h3>

<p>This is the case where we find the limitations of the Kotlin compiler. Once you’re inside a class, <code class="highlighter-rouge">this</code> gets bound to the class scope.
This makes that extension functions declared inside a class require using the standard library functions to access them, which is not very idiomatic.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// WRONG</span>
<span class="kd">class</span> <span class="nc">Parser</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="n">Monad</span><span class="p">&lt;</span><span class="n">ForOption</span><span class="p">&gt;.</span><span class="n">parseInt</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span>

  <span class="k">fun</span> <span class="p">??</span><span class="o">?.</span><span class="n">parseInts</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
<span class="p">}</span>

<span class="c1">// TEDIOUS AND NOT IDIOMATIC</span>
<span class="n">Parser</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span> <span class="n">Option</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">parseInt</span><span class="p">(</span><span class="s">"123"</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>For these cases the most ergonomic option is not to use extension functions, and instead fall back to regular parameter passing.
Once inside the method we can use the standard library functions to access the scope of the typeclass, and treat the method the same as if it was a scoped function.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Parser</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="n">parseInt</span><span class="p">(</span><span class="n">M</span><span class="p">:</span> <span class="n">Monad</span><span class="p">&lt;</span><span class="n">ForOption</span><span class="p">&gt;,</span> <span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">M</span><span class="p">.</span><span class="n">run</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>

  <span class="k">fun</span> <span class="n">parseInts</span><span class="p">(</span><span class="n">M</span><span class="p">:</span> <span class="n">Monad</span><span class="p">&lt;</span><span class="n">ForOption</span><span class="p">&gt;,</span> <span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;&gt;</span> <span class="p">=</span> <span class="n">M</span><span class="p">.</span><span class="n">run</span> <span class="p">{</span> <span class="n">ListK</span><span class="p">.</span><span class="n">traverse</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// JUST MEH</span>
<span class="n">Parser</span><span class="p">().</span><span class="n">parseInts</span><span class="p">(</span><span class="n">Option</span><span class="p">.</span><span class="n">monad</span><span class="p">(),</span> <span class="n">listOf</span><span class="p">(</span><span class="s">"1"</span><span class="p">.</span><span class="n">some</span><span class="p">(),</span> <span class="s">"2"</span><span class="p">.</span><span class="n">some</span><span class="p">()))</span>
</code></pre></div></div>

<p>We are almost back to where we started with parameter passing, at least on this first layer.
Except, there are some benefits once you’re inside these public functions, as you can declare private extension methods inside the class and you will be able to seamlessly call them as well as other scoped functions.</p>

<h2 id="composing-dependencies">Composing dependencies</h2>

<p>In several of the prior examples we have found that we depend on multiple typeclasses that are not part of the same hierarchy.
This is not an uncommon case, and it has to be addressed. How can we express this combination? Luckily, the Kotlin language comes to our aid again.</p>

<p>Kotlin has a keyword <code class="highlighter-rouge">where</code>, used in method signatures to describe multiple bounds on a generic parameter.
You can define multiple clauses for a single generic parameter that will be the type we declare an extension function on.</p>

<p>Let’s see one example of a function that depends on both <code class="highlighter-rouge">Applicative</code> and <code class="highlighter-rouge">Show</code>:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;.</span><span class="n">findUserName</span><span class="p">(</span><span class="n">S</span><span class="p">:</span> <span class="n">Show</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;,</span> <span class="n">id</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">UserId</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">S</span><span class="p">.</span><span class="n">run</span> <span class="p">{</span>
  <span class="n">id</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">fetchUser</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">show</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s do a rewrite using <code class="highlighter-rouge">where</code> to define multiple typeclass requirements.
We will create a generic parameter <code class="highlighter-rouge">TC</code> that is bound to both typeclasses. That parameter will be the one we declare an extension on.
We’ll also remove running <code class="highlighter-rouge">Show</code> as it isn’t required anymore.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">TC</span><span class="p">&gt;</span> <span class="n">TC</span><span class="p">.</span><span class="n">findUserName</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">UserId</span><span class="p">&gt;)</span>
<span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">TC</span><span class="p">:</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;,</span> <span class="n">TC</span><span class="p">:</span> <span class="n">Show</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">id</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">fetchUser</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">show</span><span class="p">()</span> <span class="p">}</span>
</code></pre></div></div>

<p>Nice! Problem solved! Now, how does one create an <code class="highlighter-rouge">Applicative</code> + <code class="highlighter-rouge">Show</code>?</p>

<h3 id="creating-impossible-types">Creating impossible types</h3>

<p>At this point is where type inference gives us an easy way of creating objects that define bounds for multiple typeclasses.
A simple helper function with an inferred return parameter saves us from having to write the type manually:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">createApplicativeShow</span><span class="p">(</span><span class="n">AP</span><span class="p">:</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;,</span> <span class="n">S</span><span class="p">:</span> <span class="n">Show</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">=</span>
  <span class="k">object</span><span class="p">:</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">AP</span><span class="p">,</span> <span class="n">Show</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">S</span>

<span class="n">createApplicativeShow</span><span class="p">(</span><span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">(),</span> <span class="n">Show</span><span class="p">.</span><span class="n">any</span><span class="p">())</span>
  <span class="p">.</span><span class="n">findUserName</span><span class="p">(</span><span class="n">Some</span><span class="p">(</span><span class="s">"1"</span><span class="p">))</span>
<span class="c1">// Some("Paco")</span>

<span class="n">createApplicativeShow</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">applicative</span><span class="p">&lt;</span><span class="n">Throwable</span><span class="p">&gt;(),</span> <span class="n">Show</span><span class="p">.</span><span class="n">any</span><span class="p">())</span>
  <span class="p">.</span><span class="n">findUserName</span><span class="p">(</span><span class="n">Some</span><span class="p">(</span><span class="s">"1"</span><span class="p">))</span>
<span class="c1">// Right("Paco")</span>
</code></pre></div></div>

<h3 id="creating-real-types">Creating real types</h3>

<p>Alternatively, you can compose the types in a new interface and give it a new name.
This way you can also skip <code class="highlighter-rouge">where</code> clauses.
The major downside is that you’ll find a combinatory explosion of new interfaces on your codebase,
so use them scarcely when you have a type that repeats itself pervasively through the codebase.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">ApplicativeShow</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;:</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;,</span> <span class="n">Show</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>

<span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">ApplicativeShow</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">User</span><span class="p">&gt;.</span><span class="n">findUserName</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">UserId</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span>

<span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">createApplicativeShow</span><span class="p">(</span><span class="n">AP</span><span class="p">:</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;,</span> <span class="n">S</span><span class="p">:</span> <span class="n">Show</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;):</span> <span class="n">ApplicativeShow</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="k">object</span><span class="p">:</span> <span class="n">ApplicativeShow</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;,</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">AP</span><span class="p">,</span> <span class="n">Show</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">S</span>
</code></pre></div></div>

<p>There is also another reason to create a new real type, when you have two colliding typeclass instances.</p>

<h3 id="disambiguating-colliding-instances">Disambiguating colliding instances</h3>

<p>You may find some cases where two typeclass requirements collide because they’re defined for the same type, or include a typeclass on the same hierarchy.
Another way of looking at this kind of collisions is when annotation-based DI frameworks need <code class="highlighter-rouge">javax.inject.Named</code>.</p>

<p>In the case of Arrow, you will need to disambiguate them manually based off fields.
This has some benefits over the DI framework approach:</p>

<ul>
  <li>it will only happen at the caller layer, once per collision</li>
  <li>it doesn’t require any maintenance changes on all the declaration sites</li>
  <li>the solution is strongly typed</li>
  <li>the solution depends on a function call rather than a string convention, so static analysis and refactor tools are available</li>
</ul>

<p>This collision happens in an example we saw before. The typeclasses <code class="highlighter-rouge">Monad&lt;F&gt;</code> and <code class="highlighter-rouge">Traverse&lt;F&gt;</code> both inherit from <code class="highlighter-rouge">Functor&lt;F&gt;</code>.
You cannot define a boundary for two different values of <code class="highlighter-rouge">F</code>. This happened in our Parser class:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Compiler error: Type parameter &lt;F&gt; for 'Functor' has inconsistent bounds: ForOption, ForListK</span>
<span class="kd">data class</span> <span class="nc">Parser</span><span class="p">:</span> <span class="n">Monad</span><span class="p">&lt;</span><span class="n">ForOption</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">Option</span><span class="p">.</span><span class="n">monad</span><span class="p">(),</span> <span class="n">Traverse</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">ListK</span><span class="p">.</span><span class="n">traverse</span><span class="p">()</span>
</code></pre></div></div>

<p>Same as with methods inside a class, we have a situation where multiple <code class="highlighter-rouge">this</code> bindings collide.
The way of disambiguating is by creating a new type that provides both bounds as functions, and has an instance in its companion object:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">ParserDependencies</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="n">MO</span><span class="p">():</span> <span class="n">Monad</span><span class="p">&lt;</span><span class="n">ForOption</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Option</span><span class="p">.</span><span class="n">monad</span><span class="p">()</span>

  <span class="k">fun</span> <span class="n">TL</span><span class="p">():</span> <span class="n">Traverse</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">ListK</span><span class="p">.</span><span class="n">traverse</span><span class="p">()</span>

  <span class="k">companion</span> <span class="k">object</span><span class="p">:</span> <span class="n">ParserDependencies</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And now we can rewrite our parser class avoiding ambiguity:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">data class</span> <span class="nc">Parser</span><span class="p">:</span> <span class="n">ParserDependencies</span> <span class="k">by</span> <span class="n">ParserDependencies</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="n">parseInt</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">MO</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="n">parseOrThrow</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">just</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Throwable</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">none</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">fun</span> <span class="n">parseInts</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;&gt;</span> <span class="p">=</span> <span class="n">TL</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span>
    <span class="n">l</span><span class="p">.</span><span class="n">k</span><span class="p">().</span><span class="n">traverse</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{</span> <span class="n">MO</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">parseInt</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}).</span><span class="n">fix</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We have the same benefits and pitfalls we had in methods inside a class.
Once inside the <code class="highlighter-rouge">run</code> blocks, we’re able to call all other scoped extension functions declared for the enclosing typeclass.
This disambiguation only happens in one of the layers, who’s responsible for the ambiguity in the first place!</p>

<p>Cool, once we have all the pieces in place, explained and understood, let’s mention one last use case: general dependency injection!</p>

<h2 id="using-di-to-inject-any-object">Using DI to inject any object</h2>

<p>Now that you know how to define new types to declare multiple dependencies, and add fields to prevent collision between typeclasses in the same hierarchy,
what prevents you from adding arbitrary data to any fields of the type? Well, the answer is nothing :D</p>

<p>Let’s grab one of our previous examples and refactor it</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">UserFetcher</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;(</span><span class="n">ME</span><span class="p">:</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Throwable</span><span class="p">&gt;,</span> <span class="kd">val</span> <span class="py">api</span><span class="p">:</span> <span class="n">ApiService</span><span class="p">):</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Throwable</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">ME</span> <span class="p">{</span>

  <span class="k">fun</span> <span class="n">getUserFriends</span><span class="p">(</span><span class="n">fid</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">UserId</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
    <span class="n">bindingCatch</span> <span class="p">{</span>
      <span class="kd">val</span> <span class="py">id</span> <span class="p">=</span> <span class="n">fid</span><span class="p">.</span><span class="n">bind</span><span class="p">()</span>
      <span class="kd">val</span> <span class="py">user</span> <span class="p">=</span> <span class="n">api</span><span class="p">.</span><span class="n">getUser</span><span class="p">(</span><span class="n">id</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
      <span class="n">user</span><span class="p">.</span><span class="n">friendIds</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">api</span><span class="p">.</span><span class="n">getUser</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}.</span><span class="n">bind</span><span class="p">()</span>
    <span class="p">}.</span><span class="n">handleError</span> <span class="p">{</span> <span class="n">listOf</span><span class="p">()</span> <span class="p">}</span>

  <span class="k">fun</span> <span class="n">createId</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">UserId</span><span class="p">&gt;</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>On the first step, we’ll create a new type enclosing all the dependencies:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">FetcherDependencies</span><span class="p">:</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Throwable</span><span class="p">&gt;</span> <span class="p">{</span>

  <span class="k">fun</span> <span class="n">api</span><span class="p">():</span> <span class="n">ApiService</span>

  <span class="k">companion</span> <span class="k">object</span> <span class="p">{</span>
    <span class="k">operator</span> <span class="k">fun</span> <span class="n">invoke</span><span class="p">(</span><span class="n">ME</span><span class="p">:</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Throwable</span><span class="p">&gt;,</span> <span class="n">api</span><span class="p">:</span> <span class="n">ApiService</span><span class="p">):</span> <span class="n">FetcherDependencies</span> <span class="p">=</span>
      <span class="k">object</span><span class="p">:</span> <span class="n">FetcherDependencies</span><span class="p">,</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Throwable</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">ME</span> <span class="p">{</span>
        <span class="k">override</span> <span class="k">fun</span> <span class="n">api</span><span class="p">()</span> <span class="p">=</span> <span class="n">api</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this type we don’t need a class anymore, as it already encloses all state.
We can move the functions to an object scope, and make them depend on <code class="highlighter-rouge">FetcherDependencies</code> and <code class="highlighter-rouge">MonadError&lt;F, Throwable&gt;</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">object</span> <span class="nc">Api</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="n">FetcherDependencies</span><span class="p">.</span><span class="n">getUserFriends</span><span class="p">(</span><span class="n">fid</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">UserId</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
    <span class="n">bindingCatch</span> <span class="p">{</span>
      <span class="kd">val</span> <span class="py">id</span> <span class="p">=</span> <span class="n">fid</span><span class="p">.</span><span class="n">bind</span><span class="p">()</span>
      <span class="kd">val</span> <span class="py">user</span> <span class="p">=</span> <span class="n">api</span><span class="p">().</span><span class="n">getUser</span><span class="p">(</span><span class="n">id</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
      <span class="n">user</span><span class="p">.</span><span class="n">friendIds</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">api</span><span class="p">().</span><span class="n">getUser</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}.</span><span class="n">bind</span><span class="p">()</span>
    <span class="p">}.</span><span class="n">handleError</span> <span class="p">{</span> <span class="n">listOf</span><span class="p">()</span> <span class="p">}</span>

  <span class="k">fun</span> <span class="n">MonadError</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Throwable</span><span class="p">&gt;.</span><span class="n">createId</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">UserId</span><span class="p">&gt;</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>

<span class="o">..</span><span class="p">.</span>

<span class="k">import</span> <span class="nn">Api.getUserFriends</span>

<span class="kd">val</span> <span class="py">deps</span> <span class="p">=</span> <span class="n">FetcherDependencies</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monadError</span><span class="p">(),</span> <span class="n">ApiService</span><span class="p">())</span>

<span class="n">deps</span><span class="p">.</span><span class="n">getUserFriends</span><span class="p">(</span><span class="n">deps</span><span class="p">.</span><span class="n">createId</span><span class="p">(</span><span class="s">"1234"</span><span class="p">))</span>
<span class="c1">// Right([User(id="33", friendIds=["1234", "987"])])</span>
</code></pre></div></div>

<p>What have we gained from this change? We have replaced one concretion, a final class, with an abstraction that’s an interface.</p>

<ul>
  <li>The code is more functional: we have one structural type and many functions that act on it</li>
  <li>A single instance of the object that’s used but not retained by the functions, so there’s single ownership</li>
  <li>We can still define as many extensions to the functionality as we want</li>
  <li>We can call any function that requires just one or some of the types, encapsulating the rest</li>
</ul>

<p>And as a consequence to all of this, testability and refactoring possibilities are through the roof!
Many of the promises of OOP, fulfilled with simple functions and interfaces.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Api.*</span>

<span class="n">with</span> <span class="p">(</span><span class="n">Option</span><span class="p">.</span><span class="n">monadError</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">createId</span><span class="p">(</span><span class="s">"123"</span><span class="p">)</span> <span class="n">shouldBe</span> <span class="n">Some</span><span class="p">(</span><span class="m">123</span><span class="p">)</span>

  <span class="n">createId</span><span class="p">(</span><span class="s">"-123"</span><span class="p">)</span> <span class="n">shouldBe</span> <span class="n">None</span>

  <span class="n">createId</span><span class="p">(</span><span class="s">"asfgasf"</span><span class="p">)</span> <span class="n">shouldBe</span> <span class="n">None</span>

  <span class="n">createId</span><span class="p">(</span><span class="s">""</span><span class="p">)</span> <span class="n">shouldBe</span> <span class="n">None</span>
<span class="p">}</span>

<span class="n">with</span> <span class="p">(</span><span class="n">FetcherDependencies</span><span class="p">(</span><span class="n">Option</span><span class="p">.</span><span class="n">monadError</span><span class="p">(),</span> <span class="n">MockApiService</span><span class="p">()))</span> <span class="p">{</span>
  <span class="n">getUserFriends</span><span class="p">(</span><span class="n">createId</span><span class="p">(</span><span class="s">""</span><span class="p">))</span> <span class="n">shouldBe</span> <span class="n">listOf</span><span class="p">()</span>

  <span class="n">getUserFriends</span><span class="p">(</span><span class="n">createId</span><span class="p">(</span><span class="s">"sfgafg"</span><span class="p">))</span> <span class="n">shouldBe</span> <span class="n">listOf</span><span class="p">()</span>

  <span class="n">getUserFriends</span><span class="p">(</span><span class="n">createId</span><span class="p">(</span><span class="s">"123"</span><span class="p">))</span> <span class="n">shouldBe</span> <span class="n">listOf</span><span class="p">(</span><span class="n">User</span><span class="p">(</span><span class="s">"321"</span><span class="p">,</span> <span class="n">listOf</span><span class="p">(</span><span class="s">"123"</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="scoping">Scoping</h3>

<p>Typeclasses are completely stateless collections of functions.
Once you start adding other objects that are stateful you need to take care of the lifecycle of your Dependencies object.</p>

<p>Luckily for us, as there is only one reference to the Syntax object that’s passed around across layers through function parameters instead of being retained by classes, it’s easy to track its lifecycle and manage it.</p>

<p>Assuming this Dependencies object is completely stateless and it lives at the global scope, a simple root value suffices:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Api.*</span>

<span class="kd">val</span> <span class="py">deps</span> <span class="p">=</span> <span class="n">FetcherDependencies</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monadError</span><span class="p">(),</span> <span class="n">ApiService</span><span class="p">())</span>

<span class="k">fun</span> <span class="n">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="n">println</span><span class="p">(</span><span class="n">deps</span><span class="p">.</span><span class="n">getUserFriends</span><span class="p">(</span><span class="n">deps</span><span class="p">.</span><span class="n">createId</span><span class="p">(</span><span class="s">"1234"</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s introduce some nuance and assume the scope is now per-screen, as you would with Android activities.
The expected lifecycle of the Dependencies object is the same as the Activity, and gets garbage collected alongside it.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Api.*</span>

<span class="kd">class</span> <span class="nc">SettingsActivity</span><span class="p">:</span> <span class="n">Activity</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">deps</span> <span class="p">=</span> <span class="n">FetcherDependencies</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monadError</span><span class="p">(),</span> <span class="n">ActivityApiService</span><span class="p">(</span><span class="k">this</span><span class="p">))</span>

  <span class="k">override</span> <span class="k">fun</span> <span class="n">onResume</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">id</span> <span class="p">=</span> <span class="n">deps</span><span class="p">.</span><span class="n">createId</span><span class="p">(</span><span class="s">"1234"</span><span class="p">)</span>

    <span class="n">user</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> 
      <span class="n">id</span><span class="p">.</span><span class="n">fix</span><span class="p">().</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="p">}.</span><span class="n">getOrElse</span> <span class="p">{</span> <span class="s">""</span> <span class="p">}</span>

    <span class="n">friends</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> 
      <span class="n">deps</span><span class="p">.</span><span class="n">getUserFriends</span><span class="p">(</span><span class="n">id</span><span class="p">).</span><span class="n">fix</span><span class="p">().</span><span class="n">getOrElse</span> <span class="p">{</span> <span class="n">emptyList</span><span class="p">()</span> <span class="p">}.</span><span class="n">joinToString</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To recap, to scope efficiently means that you have to manually create and store your Dependencies object once, at the origin of the scope, and can now implicitly pass it around across all other layers without explicitly using it as a parameter. Each function is also limited to only use the dependencies that are relevant to itself.</p>
