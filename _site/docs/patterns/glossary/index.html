<h2 id="functional-programming-glossary">Functional Programming Glossary</h2>

<p>Note: This section keeps on growing! Keep an eye on it from time to time.</p>

<p>This document is meant to be an introduction to Functional Programming for people from all backgrounds.
We’ll go through some of the key concepts and then dive into their implementation and use in real world cases.</p>

<h3 id="datatypes">Datatypes</h3>

<p>A datatype is a class that encapsulates one reusable coding pattern.
These solutions have a canonical implementation that is generalised for all possible uses.</p>

<p>Some common patterns expressed as datatypes are absence handling with <a href="/docs/datatypes/option"><code class="highlighter-rouge">Option</code></a>,
branching in code with <a href="/docs/datatypes/either"><code class="highlighter-rouge">Either</code></a>,
catching exceptions with <a href="/docs/datatypes/try"><code class="highlighter-rouge">Try</code></a>,
or interacting with the platform the program runs in using <a href="/docs/effects/io"><code class="highlighter-rouge">IO</code></a>.</p>

<p>You can read more about all the <a href="/docs/datatypes/intro">datatypes</a> that Arrow provides in its <a href="/docs/datatypes/intro">section of the docs</a>.</p>

<h3 id="typeclasses">Typeclasses</h3>

<p>Typeclasses define a set of functions associated to one type.
This behavior is checked by a test suite called the “laws” for that typeclass.</p>

<p>You can use typeclasses as a DSL to add new free functionality to an existing type
or treat them as an abstraction placeholder for any one type that can implement the typeclass.</p>

<p>Examples of these behaviors are: comparability (<a href="/docs/typeclasses/eq"><code class="highlighter-rouge">Eq</code></a>),
composability (<a href="/docs/typeclasses/monoid"><code class="highlighter-rouge">Monoid</code></a>),
its contents can be mapped from one type to another (<a href="/docs/typeclasses/functor"><code class="highlighter-rouge">Functor</code></a>),
or error recovery (<a href="/docs/typeclasses/monaderror"><code class="highlighter-rouge">MonadError</code></a>).</p>

<p>You can read more about all the <a href="/docs/typeclasses/intro">typeclasses</a> that Arrow provides in its <a href="/docs/typeclasses/intro">section of the docs</a>.</p>

<p>One example, the typeclass <code class="highlighter-rouge">Eq</code> parametrized to <code class="highlighter-rouge">F</code> defines equality between two objects of type <code class="highlighter-rouge">F</code>:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Eq</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="n">F</span><span class="p">.</span><span class="n">eqv</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="n">F</span><span class="p">):</span> <span class="n">Boolean</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="instances">Instances</h3>

<p>A single implementation of a typeclass for a specific datatype or class.
Because typeclasses require generic parameters each implementation is meant to be unique for that parameter.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">@instance</span><span class="p">(</span><span class="n">User</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
<span class="kd">interface</span> <span class="nc">UserEqInstance</span><span class="p">:</span> <span class="n">Eq</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="n">User</span><span class="p">.</span><span class="n">eqv</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="n">User</span><span class="p">):</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="n">id</span> <span class="p">==</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span>
<span class="p">}</span>
</code></pre></div></div>

<p>All typeclass instances provided Arrow can be found in the companion object of the type they’re defined for, including platform types like String or Int.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.core.*</span>
<span class="k">import</span> <span class="nn">arrow.data.*</span>
<span class="k">import</span> <span class="nn">arrow.instances.*</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span><span class="p">.</span><span class="n">eq</span><span class="p">()</span>
<span class="c1">// arrow.instances.StringKt$eq$1@1080e52c</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Option</span><span class="p">.</span><span class="n">functor</span><span class="p">()</span>
<span class="c1">// arrow.core.Instance_arrow_instances_OptionFunctorInstanceKt$functor$1@27968a3f</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MapK</span><span class="p">.</span><span class="n">semigroup</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;(</span><span class="n">Int</span><span class="p">.</span><span class="n">semigroup</span><span class="p">())</span>
<span class="c1">// arrow.data.Instance_arrow_instances_MapKSemigroupInstanceKt$semigroup$1@6c90ff73</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Either</span><span class="p">.</span><span class="n">monadError</span><span class="p">&lt;</span><span class="n">Throwable</span><span class="p">&gt;()</span>
<span class="c1">// arrow.core.Instance_arrow_instances_EitherMonadErrorInstanceKt$monadError$1@6eb45d80</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListK</span><span class="p">.</span><span class="n">traverse</span><span class="p">()</span>
<span class="c1">// arrow.data.Instance_arrow_instances_ListKTraverseInstanceKt$traverse$1@ec299</span>
</code></pre></div></div>

<p>If you’re defining your own instances and would like for them to be discoverable in their corresponding datatypes’ companion object, you can generate it by annotating them as <code class="highlighter-rouge">@instance</code>, and Arrow’s <a href="https://github.com/arrow-kt/arrow#additional-setup">annotation processor</a> will create the extension functions for you.</p>

<h3 id="type-constructors">Type constructors</h3>

<blockquote>
  <p>NOTE: This approach to type constructors will be simplified if <a href="https://github.com/Kotlin/KEEP/pull/87">KEEP-87</a> is approved. Go vote!</p>
</blockquote>

<p>A type constructor is any class or interface that has at least one generic parameter. For example,
<a href="/docs/datatypes/listk"><code class="highlighter-rouge">ListK&lt;A&gt;</code></a> or <a href="/docs/datatypes/option"><code class="highlighter-rouge">Option&lt;A&gt;</code></a>.
They’re called constructors because they’re similar to a factory function where the parameter is <code class="highlighter-rouge">A</code>, except type constructors work only for types.
So, we could say that after applying the parameter <code class="highlighter-rouge">Int</code> to the type constructor <code class="highlighter-rouge">ListK&lt;A&gt;</code> it returns a <code class="highlighter-rouge">ListK&lt;Int&gt;</code>.
As <code class="highlighter-rouge">ListK&lt;Int&gt;</code> isn’t parametrized in any generic value it is not considered a type constructor anymore, just a regular type.</p>

<p>Like functions, a type constructor with several parameters like <a href="/docs/datatypes/either"><code class="highlighter-rouge">Either&lt;L, R&gt;</code></a> can be partially applied for one of them to return another type constructor with one fewer parameter.
For example, applying <code class="highlighter-rouge">Throwable</code> to the left side yields <code class="highlighter-rouge">Either&lt;Throwable, A&gt;</code>, or applying <code class="highlighter-rouge">String</code> to the right side results in <code class="highlighter-rouge">Either&lt;E, String&gt;</code>.</p>

<p>Type constructors are useful when matched with typeclasses because they help us represent instances of parametrized classes — the containers — that work for all generic parameters — the content.
As type constructors is not a first class feature in Kotlin, Λrrow uses an interface <code class="highlighter-rouge">Kind&lt;F, A&gt;</code> to represent them.
Kind stands for Higher Kind, which is the name of the language feature that allows working directly with type constructors.</p>

<h4 id="higher-kinds">Higher Kinds</h4>

<p>In a Higher Kind with the shape <code class="highlighter-rouge">Kind&lt;F, A&gt;</code>, if <code class="highlighter-rouge">A</code> is the type of the content then <code class="highlighter-rouge">F</code> has to be the type of the container.</p>

<p>A malformed Higher Kind would use the whole type constructor to define the container, duplicating the type of the content <del><code class="highlighter-rouge">Kind&lt;Option&lt;A&gt;, A&gt;</code></del>.
This incorrect representation has large a number of issues when working with partially applied types and nested types.</p>

<p>What Λrrow does instead is define a surrogate type that’s not parametrized to represent <code class="highlighter-rouge">F</code>.
These types are named same as the container and prefixed by For, as in <code class="highlighter-rouge">ForOption</code> or <code class="highlighter-rouge">ForListK</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ForOption</span> <span class="k">private</span> <span class="k">constructor</span><span class="p">()</span>

<span class="k">sealed</span> <span class="kd">class</span> <span class="nc">Option</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">ForOption</span><span class="p">,</span> <span class="n">A</span><span class="p">&gt;</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ForListK</span> <span class="k">private</span> <span class="k">constructor</span><span class="p">()</span>

<span class="kd">data class</span> <span class="nc">ListK</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;(</span><span class="kd">val</span> <span class="py">list</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">,</span> <span class="n">A</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>As <code class="highlighter-rouge">ListK&lt;A&gt;</code> is the only existing implementation of <code class="highlighter-rouge">Kind&lt;ForListK, A&gt;</code>, we can define an extension function on <code class="highlighter-rouge">Kind&lt;ForListK, A&gt;</code> to do the downcasting safely for us.
This function by convention is called <code class="highlighter-rouge">fix()</code>, as in, fixing a type from something generic into concrete.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">,</span> <span class="n">A</span><span class="p">&gt;.</span><span class="n">fix</span><span class="p">()</span> <span class="p">=</span> <span class="k">this</span> <span class="k">as</span> <span class="n">ListK</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>This way we have can to convert from <code class="highlighter-rouge">ListK&lt;A&gt;</code> to <code class="highlighter-rouge">Kind&lt;ForListK, A&gt;</code> via simple subclassing and from <code class="highlighter-rouge">Kind&lt;ForListK, A&gt;</code> to <code class="highlighter-rouge">ListK&lt;A&gt;</code> using the function <code class="highlighter-rouge">fix()</code>.
Being able to define extension functions that work for partially applied generics is a feature from Kotlin that’s not available in Java.
You can define <code class="highlighter-rouge">fun Kind&lt;ForOption, A&gt;.fix()</code> and <code class="highlighter-rouge">fun Kind&lt;ForListK, A&gt;.fix()</code> and the compiler can smartly decide which one you’re trying to use.
If it can’t it means there’s an ambiguity you should fix!</p>

<p>The function <code class="highlighter-rouge">fix()</code> is already defined for all datatypes in Λrrow, alongside a typealias for its <code class="highlighter-rouge">Kind&lt;F, A&gt;</code> specialization done by suffixing the type with Of, as in <code class="highlighter-rouge">ListKOf&lt;A&gt;</code> or <code class="highlighter-rouge">OptionOf&lt;A&gt;</code>. If you’re creating your own datatype that’s also a type constructor and would like to create all these helper types and functions,
you can do so simply by annotating it as <code class="highlighter-rouge">@higerkind</code> and the Λrrow’s <a href="https://github.com/arrow-kt/arrow#additional-setup">annotation processor</a> will create them for you.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">@higherkind</span>
<span class="kd">data class</span> <span class="nc">ListK</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;(</span><span class="kd">val</span> <span class="py">list</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;):</span> <span class="n">ListKOf</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span>

<span class="c1">// Generates the following code:</span>
<span class="c1">//</span>
<span class="c1">// class ForListK private constructor()</span>
<span class="c1">// typealias ListKOf&lt;A&gt; = Kind&lt;ForListK, A&gt;</span>
<span class="c1">// fun ListKOf&lt;A&gt;.fix() = this as ListK&lt;A&gt;</span>
</code></pre></div></div>

<p>Note that the annotation <code class="highlighter-rouge">@higerkind</code> will also generate the integration typealiases required by <a href="/docs/integrations/kindedj">KindedJ</a> as long as the datatype is invariant. You can read more about sharing Higher Kinds and type constructors across JVM libraries in <a href="https://github.com/KindedJ/KindedJ#rationale">KindedJ’s README</a>.</p>

<h4 id="using-higher-kinds-with-typeclasses">Using Higher Kinds with typeclasses</h4>

<p>Now that we have a way of representing generic constructors for any type, we can write typeclasses that are parametrised for containers.</p>

<p>Let’s take as an example a typeclass that specifies how to map the contents of any container <code class="highlighter-rouge">F</code>. This typeclass that comes from computer science is called a <a href="/docs/typeclasses/functor"><code class="highlighter-rouge">Functor</code></a>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Functor</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">fa</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="p">&gt;,</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">B</span><span class="p">):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>See how the class is parametrized on the container <code class="highlighter-rouge">F</code>, and the function is parametrized to the content <code class="highlighter-rouge">A</code>. This way we can have a single representation that works for all mappings from <code class="highlighter-rouge">A</code> to <code class="highlighter-rouge">B</code>.</p>

<p>Let’s define an instance of <code class="highlighter-rouge">Functor</code> for the datatype <code class="highlighter-rouge">ListK</code>, our own wrapper for lists.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">@instance</span>
<span class="kd">interface</span> <span class="nc">ListKFunctorInstance</span> <span class="p">:</span> <span class="n">Functor</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">fa</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">,</span> <span class="n">A</span><span class="p">&gt;,</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">B</span><span class="p">):</span> <span class="n">ListK</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">list</span><span class="p">:</span> <span class="n">ListK</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">fa</span><span class="p">.</span><span class="n">fix</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This interface extends <code class="highlighter-rouge">Functor</code> for the value <code class="highlighter-rouge">F</code> of <code class="highlighter-rouge">ListK</code>. We use an annotation processor <code class="highlighter-rouge">@instance</code> to generate an object out of an interface with all the default methods already defined, and to add an extension function to get it into the companion object of the datatype.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">@instance</span>
<span class="kd">interface</span> <span class="nc">ListKFunctorInstance</span> <span class="p">:</span> <span class="n">Functor</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">&gt;</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Somewhere else in the codebase</span>
<span class="n">ListK</span><span class="p">.</span><span class="n">functor</span><span class="p">()</span>
<span class="c1">// arrow.data.Instance_arrow_instances_ListKFunctorInstanceKt$functor$1@3b4d79ca</span>
</code></pre></div></div>

<p>The signature of <code class="highlighter-rouge">map</code> once the types have been replaced takes a parameter <code class="highlighter-rouge">Kind&lt;ForListK, A&gt;</code>, which is the receiver, and a mapping function from <code class="highlighter-rouge">A</code> to <code class="highlighter-rouge">B</code>. This means that map will work for all instances of <code class="highlighter-rouge">ListK&lt;A&gt;</code> for whatever the value of <code class="highlighter-rouge">A</code> can be.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">fa</span><span class="p">:</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">,</span> <span class="n">A</span><span class="p">&gt;,</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">B</span><span class="p">):</span> <span class="n">ListK</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>The implementation is short. On the first line we downcast <code class="highlighter-rouge">Kind&lt;ForListK, A&gt;</code> to <code class="highlighter-rouge">ListK&lt;A&gt;</code> using <code class="highlighter-rouge">fix()</code>. Once the value has been downcasted, the implementation of map inside the <code class="highlighter-rouge">ListK&lt;A&gt;</code> we have obtained already implements the expected behavior of map.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">list</span><span class="p">:</span> <span class="n">ListK</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">fa</span><span class="p">.</span><span class="n">fix</span><span class="p">()</span>
<span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="using-higher-kinds-and-typeclasses-with-functions">Using Higher Kinds and typeclasses with functions</h4>

<p>Higher kinds are also used to model functions that require for a datatype to implement a typeclass. This way you can create functions that abstract behavior (defined by a typeclass) and allow callers to define which datatype they’d like to apply it to.</p>

<p>Let’s use the typeclass <a href="/docs/typeclasses/applicative"><code class="highlighter-rouge">Applicative</code></a>, that contains the constructor function <code class="highlighter-rouge">just()</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;:</span> <span class="n">Functor</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="p">{</span>

  <span class="c1">// Constructs the current datatype with a value of type A inside</span>
  <span class="k">fun</span> <span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">just</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="p">&gt;</span>

  <span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Once we have this typeclass behavior define we can now write a function that’s parametrized for any <code class="highlighter-rouge">F</code> that has one instance of <code class="highlighter-rouge">Applicative</code>. The function uses the constructor <code class="highlighter-rouge">just</code> to create a value of type <code class="highlighter-rouge">Kind&lt;F, User&gt;</code>, effectively generifying the return on any container <code class="highlighter-rouge">F</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;.</span><span class="n">randomUserStructure</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">User</span><span class="p">):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">User</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">AP</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">random</span><span class="p">()))</span>
</code></pre></div></div>

<p>Now lets create a simple example instance of <code class="highlighter-rouge">Applicative</code> where our <code class="highlighter-rouge">F</code> is <code class="highlighter-rouge">ListK</code>. This implementation of a <code class="highlighter-rouge">just</code> constructor is trivial for lists, as it just requires wrapping the value.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">@instance</span>
<span class="kd">interface</span> <span class="nc">ListKApplicativeInstance</span> <span class="p">:</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">just</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span> <span class="n">Kind</span><span class="p">&lt;</span><span class="n">ForListK</span><span class="p">,</span> <span class="n">A</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">ListK</span><span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

  <span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And now we can show how this function <code class="highlighter-rouge">randomUserStructure()</code> can be used for any datatype that implements <a href="/docs/typeclasses/applicative"><code class="highlighter-rouge">Applicative</code></a>. As the function returns a value <code class="highlighter-rouge">Kind&lt;F, User&gt;</code> the caller is responsible of calling <code class="highlighter-rouge">fix()</code> to downcast it to the expected value.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">ListK</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">randomUserStructure</span><span class="p">(</span><span class="o">::</span><span class="n">User</span><span class="p">).</span><span class="n">fix</span><span class="p">()</span>
<span class="c1">//[User(342)]</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">option</span> <span class="p">=</span> <span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">randomUserStructure</span><span class="p">(</span><span class="o">::</span><span class="n">User</span><span class="p">).</span><span class="n">fix</span><span class="p">()</span>
<span class="c1">//Some(User(765))</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">either</span> <span class="p">=</span> <span class="n">Either</span><span class="p">.</span><span class="n">applicative</span><span class="p">&lt;</span><span class="n">Unit</span><span class="p">&gt;().</span><span class="n">randomUserStructure</span><span class="p">(</span><span class="o">::</span><span class="n">User</span><span class="p">).</span><span class="n">fix</span><span class="p">()</span>
<span class="c1">//Right(User(221))</span>
</code></pre></div></div>

<p>Passing the instance in every function call seems like a burden. So, because <code class="highlighter-rouge">randomUserStructure</code> is an extension function for <a href="/docs/typeclasses/applicative"><code class="highlighter-rouge">Applicative</code></a> we can omit the implicit parameter as long as we are within the scope of an Applicative instance. You can use the standard functions <code class="highlighter-rouge">with</code> and <code class="highlighter-rouge">run</code> for this.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">with</span> <span class="p">(</span><span class="n">ListK</span><span class="p">.</span><span class="n">applicative</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Lots of Kotlin here</span>

    <span class="c1">// Multiple calls</span>

    <span class="n">randomUserStructure</span><span class="p">(</span><span class="o">::</span><span class="n">User</span><span class="p">).</span><span class="n">fix</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// [User(342)]</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">run</span> <span class="p">{</span>
    <span class="n">tupled</span><span class="p">(</span><span class="n">randomUserStructure</span><span class="p">(</span><span class="o">::</span><span class="n">User</span><span class="p">),</span> <span class="n">randomUserStructure</span><span class="p">(</span><span class="o">::</span><span class="n">User</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// Some(value = Tuple2(a = User(765), b = User(127)))</span>
</code></pre></div></div>

<p>It is also possible to use a form of <a href="/docs/patterns/dependency_injection"><code class="highlighter-rouge">Dependency Injection</code></a> to make the typeclass scope available to a whole class. For example, using simple delegation:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">UserFetcher</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;(</span><span class="n">AP</span><span class="p">:</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;):</span> <span class="n">Applicative</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">AP</span> <span class="p">{</span>

    <span class="k">fun</span> <span class="n">genUser</span><span class="p">()</span> <span class="p">=</span> <span class="n">randomUserStructure</span><span class="p">(</span><span class="o">::</span><span class="n">User</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">UserFetcher</span><span class="p">(</span><span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">()).</span><span class="n">genUser</span><span class="p">().</span><span class="n">fix</span><span class="p">()</span>
<span class="c1">// Some(value = User(943))</span>
</code></pre></div></div>

<p>To learn more about this <code class="highlighter-rouge">Typeclassless</code> technique you should head to the <a href="/docs/patterns/dependency_injection"><code class="highlighter-rouge">Dependency Injection</code></a> documentation.</p>
