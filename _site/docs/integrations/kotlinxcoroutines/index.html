<h2 id="kotlinxcoroutines">kotlinx.coroutines</h2>

<p>Arrow wants to provide an abstraction over multiple concurrency frameworks, in a way where their semantics match and they become interchangeable.</p>

<p>Working towards this purpose, it’s only natural that we’d add support for the framework Jetbrains provides over coroutines.
This framework is called <code class="highlighter-rouge">kotlinx.coroutines</code>, whereas the machinery necessary to create coroutines is called <code class="highlighter-rouge">kotlin.coroutines</code>.</p>

<p>The most important datatype provided by Jetbrains is <code class="highlighter-rouge">Deferred</code>. <code class="highlighter-rouge">Deferred</code> is an abstraction capable of returning 1 result and cancellation.
Its constructor is called <code class="highlighter-rouge">async</code>, and takes one suspended execution block where you can <code class="highlighter-rouge">await()</code> suspended functions.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">async</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">userProfile</span> <span class="p">=</span> <span class="n">getProfile</span><span class="p">(</span><span class="s">"userId"</span><span class="p">).</span><span class="n">await</span><span class="p">()</span>
  <span class="kd">val</span> <span class="py">friendProfiles</span> <span class="p">=</span> <span class="n">userProfile</span><span class="p">.</span><span class="n">friends</span><span class="p">().</span><span class="n">map</span> <span class="p">{</span> <span class="n">friend</span> <span class="p">-&gt;</span>
     <span class="n">getProfile</span><span class="p">(</span><span class="n">friend</span><span class="p">.</span><span class="n">id</span><span class="p">).</span><span class="n">await</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Does it look familiar? Yes! It’s the same as our <a href="/docs/patterns/monad_comprehensions">comprehensions</a>!</p>

<h3 id="improvements-over-the-library">Improvements over the library</h3>

<p>Unlike <a href="/docs/integrations/rx2">RxJava</a>, <code class="highlighter-rouge">Deferred</code> doesn’t come with a natural set of operations for error handling and recovery,
requiring users to use imperative try/catch blocks.
Luckily, Arrow comes with its own set of error handling functions in its integration with <a href="/docs/typeclasses/monaderror"><code class="highlighter-rouge">MonadError</code></a>.</p>

<p>See this faulty block</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">kotlinx.coroutines.*</span>

<span class="kd">val</span> <span class="py">deferred</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"BOOM!"</span><span class="p">)</span> <span class="p">}</span>
<span class="n">runBlocking</span> <span class="p">{</span> <span class="n">deferred</span><span class="p">.</span><span class="n">await</span><span class="p">()</span> <span class="p">}</span>
<span class="c1">// CRASH! Exception!</span>
</code></pre></div></div>

<p>What if we convert it to Arrow using <code class="highlighter-rouge">k()</code>?</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.effects.*</span>

<span class="kd">val</span> <span class="py">errorArrowWrapper</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"BOOM!"</span><span class="p">)</span> <span class="p">}.</span><span class="n">k</span><span class="p">()</span>
<span class="n">deferredWrapper</span><span class="p">.</span><span class="n">unsafeAttemptSync</span><span class="p">()</span>
<span class="c1">// Failure(RuntimeException("BOOM!"))</span>
</code></pre></div></div>

<p>And how about adding some nice error recovery!</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">recoveryArrowWrapper</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"BOOM!"</span><span class="p">)</span> <span class="p">}.</span><span class="n">k</span><span class="p">()</span>
                                 <span class="p">.</span><span class="n">handleError</span> <span class="p">{</span> <span class="m">0</span> <span class="p">}</span>
<span class="n">recoveryArrowWrapper</span><span class="p">.</span><span class="n">unsafeAttemptSync</span><span class="p">()</span>
<span class="c1">// Success(0)</span>
</code></pre></div></div>

<p>The second advantage is that we’re providing all the instances required to create an architecture that’s agnostic to the framework, so you can mix and match multiple frameworks
in a way that feels idiomatic, while not having to worry about the semantics of each implementation.</p>

<p>You can read more about FP architectures in the section on <a href="/docs/patterns/monad_transformers">Monad Transformers</a>.</p>

<h3 id="bringing-deferred-to-arrow">Bringing Deferred to Arrow</h3>

<p>To create a Deferred Arrow Wrapper you can invoke the constructor with any synchronous non-suspending function, the same way you’d use <code class="highlighter-rouge">async</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">deferredK</span> <span class="p">=</span> <span class="n">DeferredK</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"BOOM!"</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>To wrap any existing <code class="highlighter-rouge">Deferred</code> in its Arrow Wrapper counterpart you can use the extension function <code class="highlighter-rouge">k()</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">deferredWrapped</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"BOOM!"</span><span class="p">)</span> <span class="p">}.</span><span class="n">k</span><span class="p">()</span>
</code></pre></div></div>

<p>All the other usual constructors like <code class="highlighter-rouge">just()</code>, <code class="highlighter-rouge">suspend()</code>, and <code class="highlighter-rouge">async()</code> are available too, in versions that accept different values for <code class="highlighter-rouge">CoroutineStart</code> and <code class="highlighter-rouge">CoroutineContext</code>.</p>

<p>To unwrap the value of a <code class="highlighter-rouge">DeferredK</code> we provide a synchronous method called <code class="highlighter-rouge">unsafeAttemptSync()</code> that returns a <code class="highlighter-rouge">Try&lt;A&gt;</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">deferredK</span><span class="p">.</span><span class="n">unsafeAttemptSync</span><span class="p">()</span>
<span class="c1">// Failure(RuntimeException("BOOM!"))</span>
</code></pre></div></div>

<p>For unwrapping the values asynchronously you can use <code class="highlighter-rouge">unsafeRunAsync()</code>  and <code class="highlighter-rouge">runAsync()</code>.</p>

<p>The safe version takes as a parameter a callback from a result of <code class="highlighter-rouge">Either&lt;Throwable, A&gt;</code> to a new <code class="highlighter-rouge">Deferred&lt;Unit&gt;</code> instance.
All exceptions that would happen on the function parameter are automatically captured and propagated to the <code class="highlighter-rouge">Deferred&lt;Unit&gt;</code> return.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DeferredK</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"Boom!"</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">runAsync</span> <span class="p">{</span> <span class="n">result</span> <span class="p">-&gt;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">fold</span><span class="p">({</span> <span class="n">DeferredK</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">"Error found"</span><span class="p">)</span> <span class="p">}</span> <span class="p">},</span> <span class="p">{</span> <span class="n">res</span> <span class="p">-&gt;</span> <span class="n">DeferredK</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">toString</span><span class="p">())</span> <span class="p">}</span> <span class="p">})</span>
  <span class="p">}</span>
<span class="c1">// Error found</span>
</code></pre></div></div>

<p>The unsafe version requires a callback to <code class="highlighter-rouge">Unit</code> and is assumed to never throw any internal exceptions.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DeferredK</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"Boom!"</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">unsafeRunAsync</span> <span class="p">{</span> <span class="n">result</span> <span class="p">-&gt;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">fold</span><span class="p">({</span> <span class="n">println</span><span class="p">(</span><span class="s">"Error found"</span><span class="p">)</span> <span class="p">},</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">toString</span><span class="p">())</span> <span class="p">})</span>
  <span class="p">}</span>
<span class="c1">// Error found</span>
</code></pre></div></div>

<p>Note that the function <code class="highlighter-rouge">unsafeRunSync</code> returns a value that’s not wrapped on a <code class="highlighter-rouge">Try&lt;A&gt;</code>. This means that, like <code class="highlighter-rouge">async</code>, this function can crash your program.
Use it with SEVERE CAUTION.</p>

<p>It is also posible to <code class="highlighter-rouge">await()</code> on the wrapper like you would on <code class="highlighter-rouge">Deferred</code>, but losing all the benefits of Arrow.</p>

<h3 id="error-handling--recovery">Error handling &amp; recovery</h3>

<p><a href="/docs/typeclasses/monaderror"><code class="highlighter-rouge">MonadError</code></a> can be used to start a <a href="/docs/patterns/monadcomprehensions">Monad Comprehension</a> using the method <code class="highlighter-rouge">bindingCatch</code>, with all its benefits.
These benefits include capturing all exceptions that happen inside the block.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DeferredK</span><span class="p">.</span><span class="n">monadError</span><span class="p">().</span><span class="n">bindingCatch</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">songUrl</span> <span class="p">=</span> <span class="n">getSongUrlAsync</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
  <span class="kd">val</span> <span class="py">musicPlayer</span> <span class="p">=</span> <span class="n">MediaPlayer</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">songUrl</span><span class="p">)</span>
  <span class="kd">val</span> <span class="py">totalTime</span> <span class="p">=</span> <span class="n">musicPlayer</span><span class="p">.</span><span class="n">getTotaltime</span><span class="p">()</span> <span class="c1">// Oh oh, total time is 0</span>

  <span class="kd">val</span> <span class="py">timelineClick</span> <span class="p">=</span> <span class="n">audioTimeline</span><span class="p">.</span><span class="n">click</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>

  <span class="kd">val</span> <span class="py">percent</span> <span class="p">=</span> <span class="p">(</span><span class="n">timelineClick</span> <span class="p">/</span> <span class="n">totalTime</span> <span class="p">*</span> <span class="m">100</span><span class="p">).</span><span class="n">toInt</span><span class="p">()</span>

  <span class="n">percent</span>
<span class="p">}.</span><span class="n">unsafeAttemptSync</span><span class="p">()</span>
 <span class="c1">// Failure(ArithmeticException("/ by zero"))</span>
</code></pre></div></div>

<p>Several recovery methods are provided, which you can find in the documentation for <a href="/docs/typeclasses/applicativeerror"><code class="highlighter-rouge">ApplicativeError</code></a>.
The most common ones are <code class="highlighter-rouge">handleError</code> and <code class="highlighter-rouge">handleErrorWith</code>.</p>

<p>The former allows you to return a single value from a faulty block</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">recoveryArrowWrapper</span> <span class="p">=</span> <span class="n">DeferredK</span> <span class="p">{</span> <span class="n">getUserListByIdRange</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="p">}</span>
                                 <span class="p">.</span><span class="n">handleError</span> <span class="p">{</span> <span class="n">listOf</span><span class="p">()</span> <span class="p">}</span>
<span class="n">recoveryArrowWrapper</span><span class="p">.</span><span class="n">unsafeAttemptSync</span><span class="p">()</span>
<span class="c1">// Success(List())</span>
</code></pre></div></div>

<p>whereas the later allows for any <code class="highlighter-rouge">DeferredK</code> to be returned</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">recoveryArrowWrapper</span> <span class="p">=</span> <span class="n">DeferredK</span> <span class="p">{</span> <span class="n">getUserListByIdRange</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="p">}</span>
                                 <span class="p">.</span><span class="n">handleErrorWith</span> <span class="p">{</span> <span class="n">getUserListByIdRange</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span> <span class="p">}</span>
<span class="n">recoveryArrowWrapper</span><span class="p">.</span><span class="n">unsafeAttemptSync</span><span class="p">()</span>
<span class="c1">// Success(List(User(1), User(2), User(3)))</span>
</code></pre></div></div>

<h3 id="subscription-and-cancellation">Subscription and cancellation</h3>

<p><code class="highlighter-rouge">DeferredK</code> created with <code class="highlighter-rouge">bindingCatch</code> behave the same way regular <code class="highlighter-rouge">Deferred</code> do, including cancellation by disposing the subscription.</p>

<p>Note that <a href="/docs/effects/monaddefer"><code class="highlighter-rouge">MonadDefer</code></a> provides an alternative to <code class="highlighter-rouge">bindingCatch</code> called <code class="highlighter-rouge">bindingCancellable</code> returning a <code class="highlighter-rouge">arrow.Disposable</code>.
Invoking this <code class="highlighter-rouge">Disposable</code> causes an <code class="highlighter-rouge">BindingCancellationException</code> in the chain which needs to be handled by the subscriber, similarly to what <code class="highlighter-rouge">Deferred</code> does.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="err">(</span><span class="py">deferred</span><span class="p">,</span> <span class="n">unsafeCancel</span><span class="p">)</span> <span class="p">=</span>
  <span class="n">DeferredK</span><span class="p">.</span><span class="n">monadDefer</span><span class="p">().</span><span class="n">bindingCancellable</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">userProfile</span> <span class="p">=</span> <span class="n">DeferredK</span> <span class="p">{</span> <span class="n">getUserProfile</span><span class="p">(</span><span class="s">"123"</span><span class="p">)</span> <span class="p">}.</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">friendProfiles</span> <span class="p">=</span> <span class="n">userProfile</span><span class="p">.</span><span class="n">friends</span><span class="p">().</span><span class="n">map</span> <span class="p">{</span> <span class="n">friend</span> <span class="p">-&gt;</span>
        <span class="n">DeferredK</span> <span class="p">{</span> <span class="n">getProfile</span><span class="p">(</span><span class="n">friend</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}.</span><span class="n">bind</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="n">listOf</span><span class="p">(</span><span class="n">userProfile</span><span class="p">)</span> <span class="p">+</span> <span class="n">friendProfiles</span>
  <span class="p">}</span>

<span class="n">deferred</span><span class="p">.</span><span class="n">unsafeRunAsync</span> <span class="p">{</span> <span class="n">result</span> <span class="p">-&gt;</span>
  <span class="n">result</span><span class="p">.</span><span class="n">fold</span><span class="p">({</span> <span class="n">println</span><span class="p">(</span><span class="s">"Boom! caused by $it"</span><span class="p">)</span> <span class="p">},</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">toString</span><span class="p">())</span> <span class="p">})</span>
<span class="p">}</span>

<span class="n">unsafeCancel</span><span class="p">()</span>
<span class="c1">// Boom! caused by BindingCancellationException</span>
</code></pre></div></div>

<h2 id="available-instances">Available Instances</h2>

<ul>
  <li><a href="/docs/typeclasses/Applicative">Applicative</a></li>
  <li><a href="/docs/typeclasses/ApplicativeError">ApplicativeError</a></li>
  <li><a href="/docs/typeclasses/Functor">Functor</a></li>
  <li><a href="/docs/typeclasses/Monad">Monad</a></li>
  <li><a href="/docs/typeclasses/MonadError">MonadError</a></li>
  <li><a href="/docs/typeclasses/MonadDefer">MonadDefer</a></li>
  <li><a href="/docs/effects/async">Async</a></li>
  <li><a href="/docs/effects/effect">Effect</a></li>
</ul>
