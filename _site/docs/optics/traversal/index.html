<h2 id="traversal">Traversal</h2>
<p>A <code class="highlighter-rouge">Traversal</code> is an optic that can see into a structure and get, set or modify 0 to N foci.</p>

<p>It is a generalization of <a href="/docs/typeclasses/traverse"><code class="highlighter-rouge">Traverse#traverse</code></a>. Given a <code class="highlighter-rouge">Traverse&lt;F&gt;</code> we can apply a function <code class="highlighter-rouge">(A) -&gt; Kind&lt;G, B&gt;</code> to <code class="highlighter-rouge">Kind&lt;F, A&gt;</code> and get <code class="highlighter-rouge">Kind&lt;G, Kind&lt;F, B&gt;&gt;</code>.
We can think of <code class="highlighter-rouge">Kind&lt;F, A&gt;</code> as a structure <code class="highlighter-rouge">S</code> that has a focus <code class="highlighter-rouge">A</code>. So given a <code class="highlighter-rouge">PTraversal&lt;S, T, A, B&gt;</code> we can apply a function <code class="highlighter-rouge">(A) -&gt; Kind&lt;F, B&gt;</code> to <code class="highlighter-rouge">S</code> and get <code class="highlighter-rouge">Kind&lt;F, T&gt;</code>.</p>

<ul>
  <li><code class="highlighter-rouge">Traverse.traverse(fa: Kind&lt;F, A&gt;, f: (A) -&gt; Kind&lt;G, B&gt;, GA: Applicative&lt;G&gt;): Kind&lt;G, Kind&lt;F, B&gt;&gt;</code></li>
  <li><code class="highlighter-rouge">PTraversal.modifyF(s: S, f: (A) -&gt; Kind&lt;F, B&gt;, GA: Applicative&lt;F&gt;): Kind&lt;F, T&gt;</code></li>
</ul>

<p>You can get a <code class="highlighter-rouge">Traversal</code> for any existing <code class="highlighter-rouge">Traverse</code>.</p>

<pre><code class="language-kotlin:ank">import arrow.*
import arrow.optics.*
import arrow.core.*
import arrow.data.*

val listTraversal: Traversal&lt;ListKOf&lt;Int&gt;, Int&gt; = Traversal.fromTraversable(ListK.traverse())

listTraversal.modifyF(Try.applicative(), listOf(1, 2, 3).k()) {
    Try { it / 2 }
}
</code></pre>
<pre><code class="language-kotlin:ank">listTraversal.modifyF(Try.applicative(), listOf(0, 2, 3).k()) {
    Try { throw TryException.UnsupportedOperationException("Any arbitrary exception") }
}
</code></pre>

<p>Or by using any of the constructors of <code class="highlighter-rouge">Traversal</code>.</p>

<pre><code class="language-kotlin:ank">import arrow.core.*

fun &lt;A&gt; traversalTuple2Example(): Traversal&lt;Tuple2&lt;A, A&gt;, A&gt; = Traversal(
        get1 = { it.a },
        get2 = { it.b },
        set = { a, b, _ -&gt; Tuple2(a, b) }
)
</code></pre>

<p>Arrow optics also provides a number of predefined <code class="highlighter-rouge">Traversal</code> optics.</p>

<pre><code class="language-kotlin:ank">import arrow.instances.*

traversalTuple2&lt;String&gt;().combineAll(String.monoid(), "Hello, " toT "World!")
</code></pre>
<pre><code class="language-kotlin:ank">traversalTuple10&lt;Int&gt;().getAll(Tuple10(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
</code></pre>

<h2 id="composition">Composition</h2>

<p>Composing <code class="highlighter-rouge">Traversal</code> can be used for accessing and modifying foci in nested structures.</p>

<pre><code class="language-kotlin:ank">val listOfPairTraversal: Traversal&lt;ListKOf&lt;Tuple2&lt;String, String&gt;&gt;, Tuple2&lt;String, String&gt;&gt; = Traversal.fromTraversable(ListK.traverse())
val nestedInts = listOfPairTraversal compose traversalTuple2()

nestedInts.fold(String.monoid(), listOf("Hello, " toT "World ", "from " toT "nested structures!").k())
</code></pre>

<p><code class="highlighter-rouge">Traversal</code> can be composed with all optics and results in the following optics.</p>

<table>
  <thead>
    <tr>
      <th>Â </th>
      <th>Iso</th>
      <th>Lens</th>
      <th>Prism</th>
      <th>Optional</th>
      <th>Getter</th>
      <th>Setter</th>
      <th>Fold</th>
      <th>Traversal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Traversal</td>
      <td>Traversal</td>
      <td>Traversal</td>
      <td>Traversal</td>
      <td>Traversal</td>
      <td>Fold</td>
      <td>Setter</td>
      <td>Fold</td>
      <td>Traversal</td>
    </tr>
  </tbody>
</table>

<h3 id="polymorphic-traversal">Polymorphic Traversal</h3>

<p>When dealing with polymorphic types we can also have polymorphic <code class="highlighter-rouge">Traversal</code>s that allow us to morph the type of the foci.
Previously we used a <code class="highlighter-rouge">Traversal&lt;ListKOf&lt;Int&gt;, Int&gt;</code>, it was able to morph the <code class="highlighter-rouge">Int</code> values in the constructed type <code class="highlighter-rouge">ListK&lt;Int&gt;</code>.
With a <code class="highlighter-rouge">PTraversal&lt;ListKOf&lt;Int&gt;, ListKOf&lt;String&gt;, Int, String&gt;</code> we can morph an <code class="highlighter-rouge">Int</code> to a <code class="highlighter-rouge">String</code> and thus also morph the type from <code class="highlighter-rouge">ListK&lt;Int&gt;</code> to <code class="highlighter-rouge">ListK&lt;String&gt;</code>.</p>

<pre><code class="language-kotlin:ank">val pTraversal: PTraversal&lt;ListKOf&lt;Int&gt;, ListKOf&lt;String&gt;, Int, String&gt; = PTraversal.fromTraversable(ListK.traverse())

pTraversal.set(listOf(1, 2, 3, 4).k(), "Constant")
</code></pre>
<pre><code class="language-kotlin:ank">pTraversal.modify(listOf(1, 2, 3, 4).k()) {
    "At position $it"
}
</code></pre>

<h3 id="laws">Laws</h3>

<p>Arrow provides <a href="https://github.com/arrow-kt/arrow/blob/master/arrow-test/src/main/kotlin/arrow/laws/TraversalLaws.kt" target="_blank"><code class="highlighter-rouge">TraversalLaws</code></a> in the form of test cases for internal verification of lawful instances and third party apps creating their own traversal.</p>

