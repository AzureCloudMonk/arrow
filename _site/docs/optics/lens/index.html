<h2 id="lens">Lens</h2>

<p>Optics are essentially abstractions to update immutable data structures in an elegant way.
A <code class="highlighter-rouge">Lens</code> (aka functional reference) is an optic that can focus into a structure and <code class="highlighter-rouge">get</code>, <code class="highlighter-rouge">modify</code> or <code class="highlighter-rouge">set</code> its focus (target). They’re mostly used for <code class="highlighter-rouge">product types</code> such as a <code class="highlighter-rouge">data class</code> or a <code class="highlighter-rouge">TupleN</code>.</p>

<p>Lenses can be seen as a pair of functions, a getter and a setter. A <code class="highlighter-rouge">Lens&lt;S, A&gt;</code> represents a getter: <code class="highlighter-rouge">get: (S) -&gt; A</code> and <code class="highlighter-rouge">setter: (A) -&gt; (S) -&gt; S</code> where <code class="highlighter-rouge">S</code> is called the source of the <code class="highlighter-rouge">Lens</code> and <code class="highlighter-rouge">A</code> is called the focus or target of the <code class="highlighter-rouge">Lens</code>.</p>

<p>Given a simple structure <code class="highlighter-rouge">Foo</code> we can create a <code class="highlighter-rouge">Lens&lt;Foo, Int&gt;</code> to get, set or modify its value.</p>

<pre><code class="language-kotlin:ank">import arrow.optics.*

data class Foo(val value: Int)

val fooLens: Lens&lt;Foo, Int&gt; = Lens(
    get = { foo -&gt; foo.value },
    set = { value -&gt; { foo -&gt; foo.copy(value = value) } }
)

val foo = Foo(5)
</code></pre>
<pre><code class="language-kotlin:ank">fooLens.get(foo)
</code></pre>
<pre><code class="language-kotlin:ank">fooLens.set(foo, 10)
</code></pre>
<pre><code class="language-kotlin:ank">fooLens.modify(foo) { it + 1 }
</code></pre>

<p>We can also <code class="highlighter-rouge">lift</code> above function <code class="highlighter-rouge">(Int) -&gt; Int</code> to <code class="highlighter-rouge">(Foo) -&gt; Foo</code></p>

<pre><code class="language-kotlin:ank">val lift: (Foo) -&gt; Foo = fooLens.lift { it + 1 }
lift(foo)
</code></pre>

<p>We can also <code class="highlighter-rouge">modify</code> and <code class="highlighter-rouge">lift</code> the focus of a <code class="highlighter-rouge">Lens</code> using a <code class="highlighter-rouge">Functor</code></p>

<pre><code class="language-kotlin:ank">import arrow.*
import arrow.core.*

fooLens.modifyF(Option.functor(), foo) { it.some() }.fix()
</code></pre>

<pre><code class="language-kotlin:ank">val liftF: (Foo) -&gt; OptionOf&lt;Foo&gt; = fooLens.liftF(Option.functor()) { (it + 1).some() }
liftF(foo)
</code></pre>

<h3 id="composition">Composition</h3>

<p>By composing lenses we can create a telescope that allows us to focus in on nested structures.</p>

<p>At first sight a <code class="highlighter-rouge">Lens</code> does not seem very useful as it is just a getter/setter with some convenience methods. But lenses solve a couple of problems such as the composition of getters and setters. By default getters and setters do not compose and dealing with nested structures can be cumbersome.</p>

<p>Let’s examine following example. We have an <code class="highlighter-rouge">Employee</code> and he works for a certain <code class="highlighter-rouge">Company</code> located at a certain <code class="highlighter-rouge">Address</code> in a <code class="highlighter-rouge">Street</code>. And as a business requirement we have to capitalize <code class="highlighter-rouge">Street::name</code> in order to print nicer business cards.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">data class</span> <span class="nc">Street</span><span class="p">(</span><span class="kd">val</span> <span class="py">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
<span class="kd">data class</span> <span class="nc">Address</span><span class="p">(</span><span class="kd">val</span> <span class="py">city</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">street</span><span class="p">:</span> <span class="n">Street</span><span class="p">)</span>
<span class="kd">data class</span> <span class="nc">Company</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">address</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span>
<span class="kd">data class</span> <span class="nc">Employee</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">company</span><span class="p">:</span> <span class="n">Company</span><span class="p">)</span>
</code></pre></div></div>
<pre><code class="language-kotlin:ank">val employee = Employee("John Doe", Company("Arrow", Address("Functional city", Street(23, "lambda street"))))
employee
</code></pre>

<p>Without lenses we could use the <code class="highlighter-rouge">copy</code> method provided on a <code class="highlighter-rouge">data class</code> for dealing with immutable structures.</p>

<pre><code class="language-kotlin:ank">employee.copy(
        company = employee.company.copy(
                address = employee.company.address.copy(
                        street = employee.company.address.street.copy(
                                name = employee.company.address.street.name.capitalize()
                        )
                )
        )
)
</code></pre>

<p>As we can immediately see this is hard to read, does not scale very well and it draws attention away from the simple operation we wanted to do <code class="highlighter-rouge">name.capitalize()</code></p>

<p>What we actually wanted to do here is the following: focus into employee’s company <code class="highlighter-rouge">and then</code> focus into the company’s address <code class="highlighter-rouge">and then</code> focus into the address street and finally modify the street name by capitalizing it.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">employeeCompany</span><span class="p">:</span> <span class="n">Lens</span><span class="p">&lt;</span><span class="n">Employee</span><span class="p">,</span> <span class="n">Company</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Lens</span><span class="p">(</span>
        <span class="k">get</span> <span class="p">=</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">company</span> <span class="p">},</span>
        <span class="k">set</span> <span class="p">=</span> <span class="p">{</span> <span class="n">company</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="n">employee</span> <span class="p">-&gt;</span> <span class="n">employee</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">company</span> <span class="p">=</span> <span class="n">company</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">)</span>

<span class="kd">val</span> <span class="py">companyAddress</span><span class="p">:</span> <span class="n">Lens</span><span class="p">&lt;</span><span class="n">Company</span><span class="p">,</span> <span class="n">Address</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Lens</span><span class="p">(</span>
        <span class="k">get</span> <span class="p">=</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">address</span> <span class="p">},</span>
        <span class="k">set</span> <span class="p">=</span> <span class="p">{</span> <span class="n">address</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="n">company</span> <span class="p">-&gt;</span> <span class="n">company</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">address</span> <span class="p">=</span> <span class="n">address</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">)</span>

<span class="kd">val</span> <span class="py">addressStrees</span><span class="p">:</span> <span class="n">Lens</span><span class="p">&lt;</span><span class="n">Address</span><span class="p">,</span> <span class="n">Street</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Lens</span><span class="p">(</span>
        <span class="k">get</span> <span class="p">=</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">street</span> <span class="p">},</span>
        <span class="k">set</span> <span class="p">=</span> <span class="p">{</span> <span class="n">street</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="n">address</span> <span class="p">-&gt;</span> <span class="n">address</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">street</span> <span class="p">=</span> <span class="n">street</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">)</span>

<span class="kd">val</span> <span class="py">streetName</span><span class="p">:</span> <span class="n">Lens</span><span class="p">&lt;</span><span class="n">Street</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Lens</span><span class="p">(</span>
        <span class="k">get</span> <span class="p">=</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">name</span> <span class="p">},</span>
        <span class="k">set</span> <span class="p">=</span> <span class="p">{</span> <span class="n">name</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="n">street</span> <span class="p">-&gt;</span> <span class="n">street</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="p">=</span> <span class="n">name</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">)</span>

<span class="kd">val</span> <span class="py">employeeStreetName</span><span class="p">:</span> <span class="n">Lens</span><span class="p">&lt;</span><span class="n">Employee</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">employeeCompany</span> <span class="n">compose</span> <span class="n">companyAddress</span> <span class="n">compose</span> <span class="n">addressStrees</span> <span class="n">compose</span> <span class="n">streetName</span>

<span class="n">employeeStreetName</span><span class="p">.</span><span class="n">modify</span><span class="p">(</span><span class="n">employee</span><span class="p">,</span> <span class="n">String</span><span class="o">::</span><span class="n">capitalize</span><span class="p">)</span>
</code></pre></div></div>

<p>Don’t worry about the boilerplate of the lenses written above because it can be generated by Arrow so we’ve essentially replaced our original snippet with the last two lines.</p>

<p><code class="highlighter-rouge">Lens</code> can be composed with all optics and result in the following optics.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Iso</th>
      <th>Lens</th>
      <th>Prism</th>
      <th>Optional</th>
      <th>Getter</th>
      <th>Setter</th>
      <th>Fold</th>
      <th>Traversal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Lens</td>
      <td>Lens</td>
      <td>Lens</td>
      <td>Optional</td>
      <td>Optional</td>
      <td>Getter</td>
      <td>Setter</td>
      <td>Fold</td>
      <td>Traversal</td>
    </tr>
  </tbody>
</table>

<h3 id="generating-lenses">Generating lenses</h3>

<p>Lenses can be generated for a <code class="highlighter-rouge">data class</code> by the <code class="highlighter-rouge">@optics</code> annotation. For every constructor parameter of the <code class="highlighter-rouge">data class</code> a <code class="highlighter-rouge">Lens</code> will be generated. The lenses will be generated in the same package as the <code class="highlighter-rouge">data class</code> and will be named <code class="highlighter-rouge">classnameProperty()</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">@optics</span> <span class="kd">data class</span> <span class="nc">Account</span><span class="p">(</span><span class="kd">val</span> <span class="py">balance</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="kd">val</span> <span class="py">available</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
</code></pre></div></div>

<p>For <code class="highlighter-rouge">Account</code> 2 lenses will be generated <code class="highlighter-rouge">fun accountBalance(): Lens&lt;Account, Int&gt;</code> and <code class="highlighter-rouge">fun accountAvailable(): Lens&lt;Account, Int&gt;</code>.</p>

<pre><code class="language-kotlin:ank:silent">val balanceLens: Lens&lt;Account, Int&gt; = accountBalance()
</code></pre>

<h3 id="polymorphic-lenses-">Polymorphic lenses <a id="Plens"></a></h3>
<p>When dealing with polymorphic product types we can also have polymorphic lenses that allow us to morph the type of the focus (and as a result the constructed type) of our <code class="highlighter-rouge">PLens</code>. Following method is also available as <code class="highlighter-rouge">pFirstTuple2&lt;A, B, R&gt;()</code> in the <code class="highlighter-rouge">arrow.optics</code> package.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="n">tuple2</span><span class="p">():</span> <span class="n">PLens</span><span class="p">&lt;</span><span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;,</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">R</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;,</span> <span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">PLens</span><span class="p">(</span>
        <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">a</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">r</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="n">ab</span> <span class="p">-&gt;</span> <span class="n">r</span> <span class="n">toT</span> <span class="n">ab</span><span class="p">.</span><span class="n">b</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">)</span>

<span class="n">pFirstTuple2</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;().</span><span class="k">set</span><span class="p">(</span><span class="m">5</span> <span class="n">toT</span> <span class="s">"World"</span><span class="p">,</span> <span class="s">"Hello, "</span><span class="p">)</span>
<span class="c1">//Tuple2(a=Hello, , b=World)</span>
</code></pre></div></div>

<h3 id="laws">Laws</h3>

<p>Arrow provides <a href="https://github.com/arrow-kt/arrow/blob/master/arrow-test/src/main/kotlin/arrow/laws/LensLaws.kt" target="_blank"><code class="highlighter-rouge">LensLaws</code></a> in the form of test cases for internal verification of lawful instances and third party apps creating their own lenses.</p>

