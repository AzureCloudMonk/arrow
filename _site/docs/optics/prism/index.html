<h2 id="prism">Prism</h2>

<p>A <code class="highlighter-rouge">Prism</code> is a loss less invertible optic that can see into a structure and optionally find its focus. They’re mostly used for structures that have a relationship only under a certain condition. I.e. a certain <code class="highlighter-rouge">sum</code> of a <code class="highlighter-rouge">sum type</code> (<code class="highlighter-rouge">sealed class</code>), the head of a list or all whole double values and integers (safe casting).</p>

<p>Since <code class="highlighter-rouge">Prism</code> has an optional focus it can be seen as a pair of functions <code class="highlighter-rouge">getOrModify</code> and <code class="highlighter-rouge">reverseGet</code>.</p>

<ul>
  <li><code class="highlighter-rouge">getOrModify: A -&gt; Either&lt;A, B&gt;</code> meaning we can get the focus of a <code class="highlighter-rouge">Prism</code> OR return the original value</li>
  <li><code class="highlighter-rouge">reverseGet : B -&gt; A</code> meaning we can construct the source type of a <code class="highlighter-rouge">Prism</code> from a <code class="highlighter-rouge">B</code></li>
</ul>

<p>Given a <code class="highlighter-rouge">Prism&lt;S, A&gt;</code> we can write functions that work on the focus <code class="highlighter-rouge">A</code> without having to worry if the focus can be seen in <code class="highlighter-rouge">S</code>.</p>

<p>For a sum type <code class="highlighter-rouge">NetworkResult</code> we can create a <code class="highlighter-rouge">Prism</code> that has a focus into <code class="highlighter-rouge">Success</code></p>

<pre><code class="language-kotlin:ank">import arrow.core.*
import arrow.optics.*

sealed class NetworkResult {
    data class Success(val content: String): NetworkResult()
    object Failure: NetworkResult()
}

val networkSuccessPrism: Prism&lt;NetworkResult, NetworkResult.Success&gt; = Prism(
        getOrModify = { networkResult -&gt;
            when(networkResult) {
                is NetworkResult.Success -&gt; networkResult.right()
                else -&gt; networkResult.left()
            }
        },
        reverseGet = { networkResult -&gt; networkResult } //::identity
)
</code></pre>

<p>As is clear from above <code class="highlighter-rouge">Prism</code> definition it gathers two concepts: pattern matching and constructor.</p>

<p>Since sealed classes enforce a certain relationship we can omit the <code class="highlighter-rouge">reverseGet</code> parameter to create a <code class="highlighter-rouge">Prism</code> for them.</p>

<pre><code class="language-kotlin:ank:silent">val networkSuccessPrism2: Prism&lt;NetworkResult, NetworkResult.Success&gt; = Prism { networkResult -&gt;
    when (networkResult) {
        is NetworkResult.Success -&gt; networkResult.right()
        else -&gt; networkResult.left()
    }
}
</code></pre>

<p>Like mentioned we can now operate on <code class="highlighter-rouge">NetworkResult</code> as if it were <code class="highlighter-rouge">Success</code></p>

<pre><code class="language-kotlin:ank">val networkResult = NetworkResult.Success("content")

networkSuccessPrism.modify(networkResult) { success -&gt;
    success.copy(content = "different content")
}
</code></pre>

<p>We can also lift such functions.</p>

<pre><code class="language-kotlin:ank">val lifted: (NetworkResult) -&gt; NetworkResult = networkSuccessPrism.lift { success -&gt;
        success.copy(content = "different content")
}
lifted(NetworkResult.Failure)
</code></pre>

<p>We can also modify or lift functions using <code class="highlighter-rouge">Functors</code></p>

<pre><code class="language-kotlin:ank">networkSuccessPrism.modifyF(Option.applicative(), networkResult) { success -&gt;
    success.some()
}
</code></pre>
<pre><code class="language-kotlin:ank">val liftF = networkSuccessPrism.liftF(Option.applicative()) { None }
liftF(networkResult)
</code></pre>

<p><code class="highlighter-rouge">Prisms</code> can easily be created by using any of the already mentioned constructors although for a <code class="highlighter-rouge">sealed class</code> a <code class="highlighter-rouge">Prism</code> could easily be <a href="#generated-prisms">generated</a>. But we can also use a <code class="highlighter-rouge">PartialFuntion</code> to create a <code class="highlighter-rouge">Prism</code>.</p>

<pre><code class="language-kotlin:ank">val doubleToInt: Prism&lt;Double, Int&gt; = Prism(
        partialFunction = case(
                { double: Double -&gt; double.toInt().toDouble() == double }
                      toT Double::toInt
        ),
        reverseGet = Int::toDouble
)
</code></pre>

<h2 id="composition">Composition</h2>

<p>Nesting pattern matching blocks are tedious. We would prefer to define them seperately and compose them together. We can do that by composing mulitple <code class="highlighter-rouge">Prisms</code>.</p>

<p>Let’s imagine from our previous example we want to retrieve an <code class="highlighter-rouge">Int</code> from the network. We get a <code class="highlighter-rouge">Success</code> OR a <code class="highlighter-rouge">Failure</code> from the network. In case of a <code class="highlighter-rouge">Success</code> we want to safely cast the <code class="highlighter-rouge">String</code> to an <code class="highlighter-rouge">Int</code>.</p>

<pre><code class="language-kotlin:ank">import arrow.data.*

val successToInt: Prism&lt;NetworkResult.Success, Int&gt; = Prism(
        partialFunction = case({ success: NetworkResult.Success -&gt; Try { success.content.toInt() }.isSuccess() }
                toT { success -&gt; success.content.toInt() }
        ),
        reverseGet = NetworkResult::Success compose Int::toString
)

val networkInt: Prism&lt;NetworkResult, Int&gt; = networkSuccessPrism compose successToInt
</code></pre>
<pre><code class="language-kotlin:ank">networkInt.getOption(NetworkResult.Success("invalid int"))
</code></pre>
<pre><code class="language-kotlin:ank">networkInt.getOption(NetworkResult.Failure)
</code></pre>
<pre><code class="language-kotlin:ank">networkInt.getOption(NetworkResult.Success("5"))
</code></pre>
<p><code class="highlighter-rouge">Prism</code> can be composed with all optics but <code class="highlighter-rouge">Getter</code> and result in the following optics.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Iso</th>
      <th>Lens</th>
      <th>Prism</th>
      <th>Optional</th>
      <th>Getter</th>
      <th>Setter</th>
      <th>Fold</th>
      <th>Traversal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prism</td>
      <td>Prism</td>
      <td>Optional</td>
      <td>Prism</td>
      <td>Optional</td>
      <td>X</td>
      <td>Setter</td>
      <td>Fold</td>
      <td>Traversal</td>
    </tr>
  </tbody>
</table>

<h2 id="generated-prisms-">Generated prisms <a id="generated-prisms"></a></h2>

<p>Prisms can be generated for <code class="highlighter-rouge">sealed classes</code> by the <code class="highlighter-rouge">@optics</code> annotation. For every defined subtype a <code class="highlighter-rouge">Prism</code> will be generated. The prisms will be generated in the same package as the <code class="highlighter-rouge">sealed class</code> and will be named <code class="highlighter-rouge">parentnameSubtypename()</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">@optics</span> <span class="k">sealed</span> <span class="kd">class</span> <span class="nc">Shape</span> <span class="p">{</span>
  <span class="kd">data class</span> <span class="nc">Circle</span><span class="p">(</span><span class="kd">val</span> <span class="py">radius</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">:</span> <span class="n">Shape</span><span class="p">()</span>
  <span class="kd">data class</span> <span class="nc">Rectangle</span><span class="p">(</span><span class="kd">val</span> <span class="py">width</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="kd">val</span> <span class="py">height</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">:</span> <span class="n">Shape</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>
<pre><code class="language-kotlin:ank:silent">val circleShape: Prism&lt;Shape, Shape.Circle&gt; = shapeCircle()
val rectangleShape: Prism&lt;Shape, Shape.Rectangle&gt; = shapeRectangle()
</code></pre>

<h3 id="polymorphic-prisms-">Polymorphic prisms <a id="PPrism"></a></h3>
<p>When dealing with polymorphic sum types like <code class="highlighter-rouge">Try&lt;A&gt;</code> we can also have polymorphic prisms that allow us to polymorphically change the type of the focus of our <code class="highlighter-rouge">PPrism</code>. Following method is also available as <code class="highlighter-rouge">pTrySuccess&lt;A, B&gt;()</code> in the <code class="highlighter-rouge">arrow.optics</code> package.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">trySuccess</span><span class="p">():</span> <span class="n">PPrism</span><span class="p">&lt;</span><span class="n">Try</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;,</span> <span class="n">Try</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">PPrism</span><span class="p">(</span>
        <span class="n">getOrModify</span> <span class="p">=</span> <span class="p">{</span> <span class="n">aTry</span> <span class="p">-&gt;</span> <span class="n">aTry</span><span class="p">.</span><span class="n">fold</span><span class="p">({</span> <span class="n">Try</span><span class="p">.</span><span class="n">Failure</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;(</span><span class="n">it</span><span class="p">).</span><span class="n">left</span><span class="p">()</span> <span class="p">},</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">right</span><span class="p">()</span> <span class="p">})</span> <span class="p">},</span>
        <span class="n">reverseGet</span> <span class="p">=</span> <span class="p">{</span> <span class="n">b</span> <span class="p">-&gt;</span> <span class="n">Try</span><span class="p">.</span><span class="n">Success</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">}</span>
<span class="p">)</span>

<span class="kd">val</span> <span class="py">liftSuccess</span><span class="p">:</span> <span class="p">(</span><span class="n">Try</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="n">Try</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">pTrySuccess</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;().</span><span class="n">lift</span><span class="p">(</span><span class="n">Int</span><span class="o">::</span><span class="n">toString</span><span class="p">)</span>
<span class="n">liftSuccess</span><span class="p">(</span><span class="n">Try</span><span class="p">.</span><span class="n">Success</span><span class="p">(</span><span class="m">5</span><span class="p">))</span>
</code></pre></div></div>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">liftSuccess</span><span class="p">(</span><span class="n">Try</span><span class="p">.</span><span class="n">Failure</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="n">ArithmeticException</span><span class="p">(</span><span class="s">"/ by zero"</span><span class="p">)))</span>
</code></pre></div></div>

<h3 id="laws">Laws</h3>

<p>Arrow provides <a href="https://github.com/arrow-kt/arrow/blob/master/arrow-test/src/main/kotlin/arrow/laws/PrismLaws.kt" target="_blank"><code class="highlighter-rouge">PrismLaws</code></a> in the form of test cases for internal verification of lawful instances and third party apps creating their own prisms.</p>

