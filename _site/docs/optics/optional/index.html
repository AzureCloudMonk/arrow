<h2 id="optional">Optional</h2>

<p>An <code class="highlighter-rouge">Optional</code> is an optic that allows to see into a structure and getting, setting or modifying an optional focus.
It combines the properties of a <code class="highlighter-rouge">Lens</code> (getting, setting and modifying) with the properties of a <code class="highlighter-rouge">Prism</code> (an optional focus).</p>

<p><code class="highlighter-rouge">Optional</code> combines their weakest functions: <code class="highlighter-rouge">set</code> and <code class="highlighter-rouge">getOrModify</code></p>

<ul>
  <li><code class="highlighter-rouge">set: (S, A) -&gt; S</code> meaning we can look into <code class="highlighter-rouge">S</code> and set a value for an optional focus <code class="highlighter-rouge">A</code> and obtain the modified source.</li>
  <li><code class="highlighter-rouge">getOrModify: (S) -&gt; Either&lt;S, A&gt;</code> meaning we can get the focus OR return the original value</li>
</ul>

<p>For a structure <code class="highlighter-rouge">List&lt;Int&gt;</code> we can create an <code class="highlighter-rouge">Optional</code> to focus an optional head <code class="highlighter-rouge">Int</code>.</p>

<pre><code class="language-kotlin:ank">import arrow.*
import arrow.core.*
import arrow.optics.*

val optionalHead: Optional&lt;List&lt;Int&gt;, Int&gt; = Optional(
    getOrModify = { list -&gt; list.firstOrNull()?.right() ?: list.left() },
    set = { int -&gt; { list -&gt; list.mapIndexed { index, value -&gt; if (index == 0) int else value } } }
)
</code></pre>

<p>Our <code class="highlighter-rouge">optionalHead</code> allows us to operate on the head of <code class="highlighter-rouge">List&lt;Int&gt;</code> without having to worry if it is available. The <code class="highlighter-rouge">optionalHead</code> optic is by default available as <code class="highlighter-rouge">listHead&lt;Int&gt;()</code></p>

<pre><code class="language-kotlin:ank">import arrow.optics.instances.*

listHead&lt;Int&gt;().set(listOf(1, 3, 6), 5)
</code></pre>
<pre><code class="language-kotlin:ank">listHead&lt;Int&gt;().modify(listOf(1, 3, 6)) { head -&gt; head * 5 }
</code></pre>

<p>We can also lift such functions.</p>

<pre><code class="language-kotlin:ank">val lifted = listHead&lt;Int&gt;().lift { head -&gt; head * 5 }
lifted(emptyList())
</code></pre>

<p>Or modify or lift functions using <code class="highlighter-rouge">Applicative</code></p>

<pre><code class="language-kotlin:ank">listHead&lt;Int&gt;().modifyF(Try.applicative(), listOf(1, 3, 6)) { head -&gt;
    Try { head / 2 }
}
</code></pre>
<pre><code class="language-kotlin:ank">val liftedF = listHead&lt;Int&gt;().liftF(Try.applicative()) { head -&gt;
    Try { head / 0 }
}
liftedF(listOf(1, 3, 6))
</code></pre>

<p>An <code class="highlighter-rouge">Optional</code> instance can be manually constructed from any default or custom <code class="highlighter-rouge">Iso</code>, <code class="highlighter-rouge">Lens</code> or <code class="highlighter-rouge">Prism</code> instance by calling their <code class="highlighter-rouge">asOptional()</code> or by creating a custom <code class="highlighter-rouge">Optional</code> instance as shown above.</p>

<h3 id="composition">Composition</h3>

<p>We can compose <code class="highlighter-rouge">Optional</code>s to build telescopes with an optional focus. Imagine we try to retrieve a <code class="highlighter-rouge">User</code> his email from a backend. The result of our call is <code class="highlighter-rouge">Try&lt;User&gt;</code>. So we first want to look into <code class="highlighter-rouge">Try</code> which <strong>optionally</strong> could be a <code class="highlighter-rouge">Success</code> and then we want to look into <code class="highlighter-rouge">User</code> which optionally filled in his email.</p>

<pre><code class="language-kotlin:ank">data class Participant(val name: String, val email: String?)

val participantEmail: Optional&lt;Participant, String&gt; = Optional(
        getOrModify = { participant -&gt; participant.email?.right() ?: participant.left() },
        set = { email -&gt; { participant -&gt; participant.copy(email = email) } }
)

val triedEmail: Optional&lt;Try&lt;Participant&gt;, String&gt; = trySuccess&lt;Participant&gt;() compose participantEmail

triedEmail.getOption(Try.Success(Participant("test", "email")))
</code></pre>
<pre><code class="language-kotlin:ank">triedEmail.getOption(Try.Failure(IllegalStateException("Something wrong with network")))
</code></pre>

<p><code class="highlighter-rouge">Optional</code> can be composed with all optics, resulting in the following optics.</p>

<table>
  <thead>
    <tr>
      <th>Â </th>
      <th>Iso</th>
      <th>Lens</th>
      <th>Prism</th>
      <th>Optional</th>
      <th>Getter</th>
      <th>Setter</th>
      <th>Fold</th>
      <th>Traversal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Optional</td>
      <td>Optional</td>
      <td>Optional</td>
      <td>Optional</td>
      <td>Optional</td>
      <td>Fold</td>
      <td>Setter</td>
      <td>Fold</td>
      <td>Traversal</td>
    </tr>
  </tbody>
</table>

<h3 id="generating-optional">Generating optional</h3>

<p>To avoid boilerplate, optionals can be generated for <code class="highlighter-rouge">A?</code> and <code class="highlighter-rouge">Option&lt;A&gt;</code> fields for a <code class="highlighter-rouge">data class</code>. The <code class="highlighter-rouge">Optionals</code> will be generated in the same package as <code class="highlighter-rouge">data class</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">@optics</span> <span class="kd">data class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span><span class="p">?,</span> <span class="kd">val</span> <span class="py">address</span><span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Address</span><span class="p">&gt;)</span>
</code></pre></div></div>
<pre><code class="language-kotlin:ank:silent">val optionalAge: Optional&lt;Person, Int&gt; = personAge()
val optionalAddress: Optional&lt;Person, Address&gt; = personAddress()
</code></pre>

<h3 id="polymorphic-optional">Polymorphic optional</h3>

<p>A <code class="highlighter-rouge">POptional</code> is very similar to <a href="docs/optics/Lens#Plens">PLens</a> and <a href="docs/optics/Prism/Prism#PPrism">PPrism</a> so lets see if we can combine both examples shown in their documentation.</p>

<p>Given a <code class="highlighter-rouge">PPrism</code> with a focus into <code class="highlighter-rouge">Success</code> of <code class="highlighter-rouge">Try&lt;Tuple2&lt;Int, String&gt;&gt;</code> that can polymorphically change its content to <code class="highlighter-rouge">Tuple2&lt;String, String&gt;</code> and a <code class="highlighter-rouge">PLens</code> with a focus into the <code class="highlighter-rouge">Tuple2&lt;Int, String&gt;</code> that can morph the first parameter from <code class="highlighter-rouge">Int</code> to <code class="highlighter-rouge">String</code>. We can compose them together build an <code class="highlighter-rouge">Optional</code> that can look into <code class="highlighter-rouge">Try</code> and morph the first type of the <code class="highlighter-rouge">Tuple2</code> within.</p>

<pre><code class="language-kotlin:ank">val pprism = pTrySuccess&lt;Tuple2&lt;Int, String&gt;, Tuple2&lt;String, String&gt;&gt;()
val plens = pFirstTuple2&lt;Int, String, String&gt;()

val successTuple2: POptional&lt;Try&lt;Tuple2&lt;Int, String&gt;&gt;, Try&lt;Tuple2&lt;String, String&gt;&gt;, Int, String&gt; =
        pprism compose plens

val lifted: (Try&lt;Tuple2&lt;Int, String&gt;&gt;) -&gt; Try&lt;Tuple2&lt;String, String&gt;&gt; = successTuple2.lift { _ -&gt; "Hello, " }
lifted(Try.Success(5 toT "World!"))
</code></pre>
<pre><code class="language-kotlin:ank">lifted(Try.Failure&lt;Tuple2&lt;Int, String&gt;&gt;(IllegalStateException("something went wrong")))
</code></pre>

<h3 id="laws">Laws</h3>

<p>Arrow provides <a href="https://github.com/arrow-kt/arrow/blob/master/arrow-test/src/main/kotlin/arrow/laws/OptionalLaws.kt" target="_blank"><code class="highlighter-rouge">OptionalLaws</code></a> in the form of test cases for internal verification of lawful instances and third party apps creating their own optionals.</p>

