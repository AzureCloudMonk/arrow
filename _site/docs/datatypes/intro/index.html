<h2 id="datatypes">Datatypes</h2>

<p>A datatype is a an abstraction that encapsulates one reusable coding pattern.
These solutions have a canonical implementation that is generalised for all possible uses.</p>

<p>A datatype is implemented by a data class, or a sealed hierarchy of data classes and objects.
These datatypes are generalised by having one or several generic parameters,
and to become a <a href="/docs/patterns/glossary/">type constructor</a> they implement the interface <a href="/docs/patterns/glossary/"><code class="highlighter-rouge">Kind</code></a> for these generic parameters.
Datatypes work over themselves, never directly over the values defined by its generic parameters.</p>

<h4 id="example">Example</h4>

<p><code class="highlighter-rouge">Option&lt;A&gt;</code> is a datatype that represents absence.
It has one generic parameter <code class="highlighter-rouge">A</code>, representing the type of the values that <code class="highlighter-rouge">Option</code> may contain.
<code class="highlighter-rouge">Option</code> can be specialized for any type <code class="highlighter-rouge">A</code> because this type does not affect its behavior.
<code class="highlighter-rouge">Option</code> behaves the same for <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">String</code> or <code class="highlighter-rouge">DomainUserClass</code>.
To indicate that <code class="highlighter-rouge">Option</code> is a <a href="/docs/patterns/glossary/">type constructor</a> for all values of <code class="highlighter-rouge">A</code> it implements <code class="highlighter-rouge">OptionOf&lt;A&gt;</code>, which is a typealias of <code class="highlighter-rouge">Kind&lt;ForOption, A&gt;</code>.</p>

<p>The implementation of <code class="highlighter-rouge">Option&lt;A&gt;</code> is a sealed class with two subtypes: an object <code class="highlighter-rouge">None</code> and a data class <code class="highlighter-rouge">Some&lt;A&gt;</code>.
<code class="highlighter-rouge">Some&lt;A&gt;</code> represents presence of the value and thus it has one field containing it, and <code class="highlighter-rouge">None</code> represents absence.</p>

<p>All operations over <code class="highlighter-rouge">Option</code> have to take into account absence or presence,
so there is a function <code class="highlighter-rouge">fold()</code> that takes a continuation function per case, <code class="highlighter-rouge">() -&gt; B</code> and <code class="highlighter-rouge">(A) -&gt; B</code>.
The implementation of <code class="highlighter-rouge">fold()</code> is a simple <code class="highlighter-rouge">when</code> that checks whether <code class="highlighter-rouge">this</code> is a <code class="highlighter-rouge">None</code> or a <code class="highlighter-rouge">Some&lt;A&gt;</code>, and it applies the appropriate continuation function.</p>

<p>All other functions provided by <code class="highlighter-rouge">Option</code> are implemented by using <code class="highlighter-rouge">fold()</code>, making for idiomatic helper functions like <code class="highlighter-rouge">getOrNull</code>, <code class="highlighter-rouge">getOrElse</code>, or <code class="highlighter-rouge">map</code>. These functions work for any value of <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>. This way, what <code class="highlighter-rouge">Option</code> does for each individual case of <code class="highlighter-rouge">String</code>, <code class="highlighter-rouge">Int</code> or absence is up to the functions passed by the user.</p>

<p>Feel free to explore the <a href="https://github.com/arrow-kt/arrow/blob/master/modules/core/arrow-core/src/main/kotlin/arrow/core/Option.kt">implementation of <code class="highlighter-rouge">Option</code></a> and <a href="https://github.com/arrow-kt/arrow/tree/master/modules/core/arrow-data/src/main/kotlin/arrow/data">other datatypes</a> to discover their behavior!</p>

<h3 id="datatypes-in-arrow">Datatypes in Arrow</h3>

<p>We will list all the datatypes available in arrow by the module they belong to, and a short description of the coding pattern they abstract.</p>

<h4 id="core">Core</h4>

<p>Core contains the datatypes that are also used by the public API of several <a href="/docs/patterns/glossary/">typeclasses</a>,
so they are always required.</p>

<ul>
  <li>
    <p><a href="/docs/datatypes/id/"><code class="highlighter-rouge">Id</code></a> - a simple wrapper without any behavior, used mostly for testing</p>
  </li>
  <li>
    <p><a href="/docs/datatypes/option/"><code class="highlighter-rouge">Option</code></a> - absence of a value, or failure to construct a correct value</p>
  </li>
  <li>
    <p><a href="/docs/datatypes/either/"><code class="highlighter-rouge">Either</code></a> - an if/else branch in execution</p>
  </li>
  <li>
    <p><a href="/docs/datatypes/eval/"><code class="highlighter-rouge">Eval</code></a> - lazy evaluation of functions with stack safety and memoization</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">TupleN</code> - a heterogeneous grouping of 2-9 values without creating a named class</p>
  </li>
</ul>

<h4 id="data">Data</h4>

<p>Data contains the bulk of the datatypes provided by Arrow. We can separate them onto several categories.</p>

<h5 id="general-use">General use</h5>

<ul>
  <li>
    <p><a href="/docs/datatypes/nonemptylist/"><code class="highlighter-rouge">NonEmptyList</code></a> - a homogeneous list that has at least 1 value</p>
  </li>
  <li>
    <p><a href="/docs/datatypes/ior/"><code class="highlighter-rouge">Ior</code></a> - a branch in execution for three possible paths: one, two, or both</p>
  </li>
  <li>
    <p><a href="/docs/datatypes/const/"><code class="highlighter-rouge">Const</code></a> - tags a value with a “phantom generic” that’s never instantiated, and it can be used for example to represents units or state</p>
  </li>
  <li>
    <p><a href="/docs/datatypes/coproduct/"><code class="highlighter-rouge">Coproduct</code></a> - constructs a new composed type from two datatypes, allowing to contain and operate on either one of them</p>
  </li>
</ul>

<h5 id="error-handling">Error handling</h5>

<ul>
  <li>
    <p><a href="/docs/datatypes/try/"><code class="highlighter-rouge">Try</code></a> - returns the result of executing a block of code that can fail and throw exceptions</p>
  </li>
  <li>
    <p><a href="/docs/datatypes/validated/"><code class="highlighter-rouge">Validated</code></a> - returns the result of aggregating multiple calculations that can fail, and it also aggregates the errors</p>
  </li>
</ul>

<h5 id="readerwriterstate">Reader/Writer/State</h5>

<ul>
  <li>
    <p><a href="/docs/datatypes/kleisli/"><code class="highlighter-rouge">Kleisli</code></a> - similar to Dependency Injection and Inversion of Control, it represents a calculation with a dependency on an external context</p>
  </li>
  <li>
    <p><a href="/docs/datatypes/reader/"><code class="highlighter-rouge">Reader</code></a> - same as kleisli but operating over the <code class="highlighter-rouge">Id</code> datatype</p>
  </li>
  <li>
    <p><a href="/docs/datatypes/writert/"><code class="highlighter-rouge">Writer</code></a> - represents calculations that carry over one extra aggregated value, generally a logger or reporter</p>
  </li>
  <li>
    <p><a href="/docs/datatypes/state/"><code class="highlighter-rouge">State</code></a> - represents a stateful calculation with a carried value that can be read from or modified, like a combination of reader and writer</p>
  </li>
</ul>

<h5 id="wrappers">Wrappers</h5>

<p>These types wrap over some of Kotlin’s collections and functions to give them capabilities related to <a href="/docs/typeclasses/intro/">typeclasses</a> provided by Arrow.</p>

<ul>
  <li>
    <p><a href="/docs/datatypes/listk/"><code class="highlighter-rouge">ListK</code></a></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/sequencek/"><code class="highlighter-rouge">SequenceK</code></a></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/setk/"><code class="highlighter-rouge">SetK</code></a></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/mapk/"><code class="highlighter-rouge">MapK</code></a></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/sortedmapk/"><code class="highlighter-rouge">SortedMapK</code></a></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/function0/"><code class="highlighter-rouge">Function0</code></a></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/function1/"><code class="highlighter-rouge">Function1</code></a></p>
  </li>
</ul>

<h5 id="transformers">Transformers</h5>

<p>A transformer is a special kind of datatype that allows combining two datatypes to give one of them the abstractions of another</p>

<ul>
  <li>
    <p><a href="/docs/datatypes/optiont/"><code class="highlighter-rouge">OptionT</code></a> - gives the datatype wrapped the properties of <code class="highlighter-rouge">Option</code></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/eithert/"><code class="highlighter-rouge">EitherT</code></a> - gives the datatype wrapped the properties of <code class="highlighter-rouge">Either</code></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/kleisli/"><code class="highlighter-rouge">ReaderT</code></a> - gives the datatype wrapped the properties of <code class="highlighter-rouge">Reader</code></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/writert/"><code class="highlighter-rouge">WriterT</code></a> - gives the datatype wrapped the properties of <code class="highlighter-rouge">Writer</code></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/statet/"><code class="highlighter-rouge">StateT</code></a> - gives the datatype wrapped the properties of <code class="highlighter-rouge">State</code></p>
  </li>
</ul>

<h5 id="codata">Codata</h5>

<p>TODO</p>

<ul>
  <li>
    <p><a href="/docs/datatypes/cokleisli/"><code class="highlighter-rouge">Cokleisli</code></a></p>
  </li>
  <li>
    <p><a href="/docs/datatypes/coreader/"><code class="highlighter-rouge">Coreader</code></a></p>
  </li>
</ul>

<h4 id="effects">Effects</h4>

<p>All effects are different implementations of the same abstraction: lazy execution of code that can move to other threads and cause exceptions.
They are more general than the other datatypes as they combine the abstractions of several of them.</p>

<ul>
  <li>
    <p><a href="/docs/effects/io/"><code class="highlighter-rouge">IO</code></a></p>
  </li>
  <li>
    <p><a href="/docs/integrations/kotlinxcoroutines/"><code class="highlighter-rouge">Deferred</code></a></p>
  </li>
  <li>
    <p><a href="/docs/integrations/rx2/"><code class="highlighter-rouge">Observable</code></a></p>
  </li>
</ul>

<h4 id="free">Free</h4>

<p><a href="/docs/patterns/free_algebras/">Free</a> is a general abstraction to represent <a href="/docs/patterns/free_algebras/">Domain Specific Languages</a> that can be interpreted using Effects.</p>

<ul>
  <li>
    <p><a href="/docs/free/free/"><code class="highlighter-rouge">Free</code></a></p>
  </li>
  <li>
    <p><a href="/docs/effects/freeapplicative/"><code class="highlighter-rouge">FreeApplicative</code></a></p>
  </li>
  <li>
    <p><a href="/docs/free/cofree/"><code class="highlighter-rouge">Cofree</code></a></p>
  </li>
  <li>
    <p><a href="/docs/free/yoneda/"><code class="highlighter-rouge">Yoneda</code></a></p>
  </li>
  <li>
    <p><a href="/docs/free/coyoneda/"><code class="highlighter-rouge">Coyoneda</code></a></p>
  </li>
</ul>
