<h2 id="statet">StateT</h2>

<p><code class="highlighter-rouge">StateT</code> also known as the <code class="highlighter-rouge">State</code> monad transformer allows to compute inside the context when <code class="highlighter-rouge">State</code> is nested in a different monad.</p>

<p>One issue we face with monads is that they don’t compose. This can cause your code to get really hairy when trying to combine structures like <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">State</code>. But there’s a simple solution, and we’re going to explain how you can use Monad Transformers to alleviate this problem.</p>

<p>For our purposes here, we’re going to transform a monad that serves as a container that represents branching as an an error (left) or state (right) where computation can be performed. Given that both <code class="highlighter-rouge">State&lt;S, A&gt;</code> and <code class="highlighter-rouge">Either&lt;L, R&gt;</code> would be examples of datatypes that provide instances for the <code class="highlighter-rouge">Monad</code> typeclasses.</p>

<p>Because <a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose/">monads don’t compose</a>, we may end up with nested structures such as <code class="highlighter-rouge">Either&lt;Error, State&lt;Either&lt;Error, State&lt;S, Unit&gt;&gt;, Unit&gt;&gt;</code> when using <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">State</code> together. Using Monad Transformers can help us to reduce this boilerplate.</p>

<p>In the most basic of scenarios, we’ll only be dealing with one monad at a time making our lives nice and easy. However, it’s not uncommon to get into scenarios where some function calls will return <code class="highlighter-rouge">Either&lt;Error, A&gt;</code>, and others will return <code class="highlighter-rouge">State&lt;S, A&gt;</code>.</p>

<p>So let’s rewrite the example of <a href="/docs/datatypes/state"><code class="highlighter-rouge">State</code> docs</a>, but instead of representing the <code class="highlighter-rouge">Stack</code> as an optional <code class="highlighter-rouge">NonEmptyList</code> let’s represent it as a <code class="highlighter-rouge">List</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>
<span class="k">import</span> <span class="nn">arrow.core.*</span>
<span class="k">import</span> <span class="nn">arrow.data.*</span>
<span class="k">import</span> <span class="nn">arrow.typeclasses.*</span>

<span class="k">typealias</span> <span class="n">Stack</span> <span class="p">=</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span>

<span class="k">fun</span> <span class="n">pop</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">):</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">Stack</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">first</span><span class="p">().</span><span class="n">let</span> <span class="p">{</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">toT</span> <span class="n">it</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">):</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">Stack</span><span class="p">,</span> <span class="n">Unit</span><span class="p">&gt;</span> <span class="p">=</span>
        <span class="n">listOf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">*</span><span class="n">stack</span><span class="p">.</span><span class="n">toTypedArray</span><span class="p">())</span> <span class="n">toT</span> <span class="n">Unit</span>

<span class="k">fun</span> <span class="n">stackOperations</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">):</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">Stack</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="err">(</span><span class="py">s1</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">=</span> <span class="n">push</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
    <span class="kd">val</span> <span class="err">(</span><span class="py">s2</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pop</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stackOperations</span><span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="s">"!"</span><span class="p">))</span>
<span class="c1">// Tuple2(a=[world, !], b=hello)</span>
</code></pre></div></div>

<p>But if we now <code class="highlighter-rouge">pop</code> an empty <code class="highlighter-rouge">Stack</code> it will result in <code class="highlighter-rouge">java.util.NoSuchElementException: List is empty.</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_stackOperations</span><span class="p">(</span><span class="n">listOf</span><span class="p">())</span> <span class="c1">//java.util.NoSuchElementException: List is empty.</span>
</code></pre></div></div>

<p>Luckily Arrow offers some nice solutions <a href="/docs/patterns/error_handling"><code class="highlighter-rouge">Functional Error Handling</code> docs</a>.
Now we can model our error domain with ease.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="kd">class</span> <span class="nc">StackError</span> <span class="p">{</span>
    <span class="kd">object</span> <span class="nc">StackEmpty</span> <span class="p">:</span> <span class="n">StackError</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">typealias</span> <span class="n">StackEmpty</span> <span class="p">=</span> <span class="n">StackError</span><span class="p">.</span><span class="n">StackEmpty</span>

<span class="k">fun</span> <span class="n">popE</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">):</span> <span class="n">Either</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">,</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">Stack</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="n">StackEmpty</span><span class="p">.</span><span class="n">left</span><span class="p">()</span>
        <span class="k">else</span> <span class="n">stack</span><span class="p">.</span><span class="n">first</span><span class="p">().</span><span class="n">let</span> <span class="p">{</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">toT</span> <span class="n">it</span>
        <span class="p">}.</span><span class="n">right</span><span class="p">()</span>

<span class="k">fun</span> <span class="n">pushE</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">):</span> <span class="n">Either</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">,</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">Stack</span><span class="p">,</span> <span class="n">Unit</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
        <span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">*</span><span class="n">stack</span><span class="p">.</span><span class="n">toTypedArray</span><span class="p">())</span> <span class="n">toT</span> <span class="n">Unit</span><span class="p">).</span><span class="n">right</span><span class="p">()</span>

<span class="k">fun</span> <span class="n">stackOperationsE</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">):</span> <span class="n">Either</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">,</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">Stack</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">pushE</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="n">stack</span><span class="p">).</span><span class="n">flatMap</span> <span class="p">{</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">-&gt;</span>
        <span class="n">popE</span><span class="p">(</span><span class="n">s1</span><span class="p">).</span><span class="n">flatMap</span> <span class="p">{</span> <span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">-&gt;</span>
            <span class="n">popE</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stackOperationsE</span><span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="s">"!"</span><span class="p">))</span>
<span class="c1">// Right(b=Tuple2(a=[world, !], b=hello))</span>
</code></pre></div></div>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stackOperationsE</span><span class="p">(</span><span class="n">listOf</span><span class="p">())</span>
<span class="c1">// Left(a=Line_3$StackError$StackEmpty@53995542)</span>
</code></pre></div></div>

<p>As is immediately clear, this code while properly modelling the errors, has become more complex but our signature now represents a simple <code class="highlighter-rouge">Stack</code> as a <code class="highlighter-rouge">List</code> with an error domain.
Let’s refactor our manual state management in the form of <code class="highlighter-rouge">(S) -&gt; Tuple2&lt;S, A&gt;</code> to <code class="highlighter-rouge">State</code>.</p>

<p>So what we want is a return type that represents <code class="highlighter-rouge">Either</code> a <code class="highlighter-rouge">StackError</code> or a certain <code class="highlighter-rouge">State</code> of <code class="highlighter-rouge">Stack.</code> When working with <code class="highlighter-rouge">State</code> we don’t pass around <code class="highlighter-rouge">Stack</code> anymore, so there is no parameter to check if the <code class="highlighter-rouge">Stack</code> is empty.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">_popS</span><span class="p">():</span> <span class="n">Either</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">,</span> <span class="n">StateT</span><span class="p">&lt;</span><span class="n">ForId</span><span class="p">,</span> <span class="n">Stack</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">=</span> <span class="n">TODO</span><span class="p">()</span>
</code></pre></div></div>

<p>The only thing we can do is handle this with <code class="highlighter-rouge">StateT</code>. We want to wrap <code class="highlighter-rouge">State</code> with <code class="highlighter-rouge">Either</code>.
<code class="highlighter-rouge">EitherKindPartial</code> is an alias that helps us to fix <code class="highlighter-rouge">StackError</code> as the left type parameter for <code class="highlighter-rouge">Either&lt;L, R&gt;</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">popS</span><span class="p">()</span> <span class="p">=</span> <span class="n">StateT</span><span class="p">&lt;</span><span class="n">EitherPartialOf</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">&gt;,</span> <span class="n">Stack</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;(</span><span class="n">Either</span><span class="p">.</span><span class="n">monad</span><span class="p">())</span> <span class="p">{</span> <span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span> <span class="p">-&gt;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="n">StackEmpty</span><span class="p">.</span><span class="n">left</span><span class="p">()</span>
    <span class="k">else</span> <span class="n">stack</span><span class="p">.</span><span class="n">first</span><span class="p">().</span><span class="n">let</span> <span class="p">{</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">toT</span> <span class="n">it</span>
    <span class="p">}.</span><span class="n">right</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="n">pushS</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">=</span> <span class="n">StateT</span><span class="p">&lt;</span><span class="n">EitherPartialOf</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">&gt;,</span> <span class="n">Stack</span><span class="p">,</span> <span class="n">Unit</span><span class="p">&gt;(</span><span class="n">Either</span><span class="p">.</span><span class="n">monad</span><span class="p">())</span> <span class="p">{</span> <span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span> <span class="p">-&gt;</span>
    <span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">*</span><span class="n">stack</span><span class="p">.</span><span class="n">toTypedArray</span><span class="p">())</span> <span class="n">toT</span> <span class="n">Unit</span><span class="p">).</span><span class="n">right</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="n">stackOperationsS</span><span class="p">():</span> <span class="n">StateT</span><span class="p">&lt;</span><span class="n">EitherPartialOf</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">&gt;,</span> <span class="n">Stack</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span>
    <span class="n">pushS</span><span class="p">(</span><span class="s">"a"</span><span class="p">).</span><span class="n">flatMap</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monad</span><span class="p">())</span> <span class="p">{</span> <span class="n">_</span> <span class="p">-&gt;</span>
        <span class="n">popS</span><span class="p">().</span><span class="n">flatMap</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monad</span><span class="p">())</span> <span class="p">{</span> <span class="n">_</span> <span class="p">-&gt;</span>
            <span class="n">popS</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}.</span><span class="n">fix</span><span class="p">()</span>

<span class="n">stackOperationsS</span><span class="p">().</span><span class="n">runM</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monad</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">&gt;(),</span> <span class="n">listOf</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="s">"!"</span><span class="p">))</span>
<span class="c1">// Right(b=Tuple2(a=[world, !], b=hello))</span>
</code></pre></div></div>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stackOperationsS</span><span class="p">().</span><span class="n">runM</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monad</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">&gt;(),</span> <span class="n">listOf</span><span class="p">())</span>
<span class="c1">// Left(a=Line_3$StackError$StackEmpty@53995542)</span>
</code></pre></div></div>

<p>While our code looks very similar to what we had before there are some key advantages. State management is now contained within <code class="highlighter-rouge">State</code> and we are dealing only with 1 monad instead of 2 nested monads so we can use monad bindings!</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">stackOperationsS2</span><span class="p">()</span> <span class="p">=</span> <span class="n">StateT</span><span class="p">.</span><span class="n">monad</span><span class="p">&lt;</span><span class="n">EitherPartialOf</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">&gt;,</span> <span class="n">Stack</span><span class="p">&gt;(</span><span class="n">Either</span><span class="p">.</span><span class="n">monad</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">&gt;()).</span><span class="n">binding</span> <span class="p">{</span>
    <span class="n">pushS</span><span class="p">(</span><span class="s">"a"</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">popS</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">string</span> <span class="p">=</span> <span class="n">popS</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">string</span>
<span class="p">}.</span><span class="n">fix</span><span class="p">()</span>

<span class="n">stackOperationsS2</span><span class="p">().</span><span class="n">runM</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monad</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">&gt;(),</span> <span class="n">listOf</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="s">"!"</span><span class="p">))</span>
<span class="c1">// Right(b=Tuple2(a=[world, !], b=hello))</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stackOperationsS2</span><span class="p">().</span><span class="n">runM</span><span class="p">(</span><span class="n">Either</span><span class="p">.</span><span class="n">monad</span><span class="p">&lt;</span><span class="n">StackError</span><span class="p">&gt;(),</span> <span class="n">listOf</span><span class="p">())</span>
<span class="c1">// Left(a=Line_3$StackError$StackEmpty@53995542)</span>
</code></pre></div></div>

<h2 id="available-instances">Available Instances</h2>

<ul>
  <li><a href="/docs/typeclasses/applicative">Applicative</a></li>
  <li><a href="/docs/typeclasses/applicativeerror">ApplicativeError</a></li>
  <li><a href="/docs/typeclasses/functor">Functor</a></li>
  <li><a href="/docs/typeclasses/monad">Monad</a></li>
  <li><a href="/docs/typeclasses/monaderror">MonadError</a></li>
  <li><a href="/docs/typeclasses/monadstate">MonadState</a></li>
</ul>

<p>Take a look at the <a href="/docs/datatypes/eithert"><code class="highlighter-rouge">EitherT</code> docs</a> or <a href="/docs/datatypes/optiont"><code class="highlighter-rouge">OptionT</code> docs</a> for an alternative version monad transformer for achieving different goals.</p>
