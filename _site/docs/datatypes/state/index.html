<h2 id="state">State</h2>

<p><code class="highlighter-rouge">State</code> is a structure that provides a functional approach to handling application state. <code class="highlighter-rouge">State&lt;S, A&gt;</code> is basically a function <code class="highlighter-rouge">S -&gt; Tuple2(S, A)</code>, where <code class="highlighter-rouge">S</code> is the type that represents your state and <code class="highlighter-rouge">A</code> is the result the function produces. In addition to returning the result of type <code class="highlighter-rouge">A</code>, the function returns a new <code class="highlighter-rouge">S</code> value, which is the updated state.</p>

<h2 id="stack">Stack</h2>

<p>Let’s build a simple Stack using Arrow’s NonEmptyList and Option:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>
<span class="k">import</span> <span class="nn">arrow.core.*</span>
<span class="k">import</span> <span class="nn">arrow.data.*</span>

<span class="k">typealias</span> <span class="n">Stack</span> <span class="p">=</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Nel</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;</span>
</code></pre></div></div>

<p>Now we only need the push and pop methods, as follows:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>

<span class="k">fun</span> <span class="n">pop</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">)</span> <span class="p">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">fold</span><span class="p">({</span>
    <span class="n">None</span> <span class="n">toT</span> <span class="n">None</span>
<span class="p">},</span> <span class="p">{</span>
    <span class="n">Nel</span><span class="p">.</span><span class="n">fromList</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">tail</span><span class="p">)</span> <span class="n">toT</span> <span class="n">it</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">some</span><span class="p">()</span>
<span class="p">})</span>

<span class="k">fun</span> <span class="n">push</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">fold</span><span class="p">({</span>
    <span class="n">Nel</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">some</span><span class="p">()</span> <span class="n">toT</span> <span class="n">Unit</span>
<span class="p">},</span> <span class="p">{</span>
    <span class="n">Nel</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">all</span><span class="p">).</span><span class="n">some</span><span class="p">()</span> <span class="n">toT</span> <span class="n">Unit</span>
<span class="p">})</span>

<span class="k">fun</span> <span class="n">stackOperations</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">):</span> <span class="n">Tuple2</span><span class="p">&lt;</span><span class="n">Stack</span><span class="p">,</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="err">(</span><span class="py">s1</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">=</span> <span class="n">push</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="s">"a"</span><span class="p">)</span>
    <span class="kd">val</span> <span class="err">(</span><span class="py">s2</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pop</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stackOperations</span><span class="p">(</span><span class="n">Nel</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="s">"!"</span><span class="p">).</span><span class="n">some</span><span class="p">())</span>
<span class="c1">// Tuple2(a=Some(NonEmptyList(all=[world, !])), b=Some(hello))</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stackOperations</span><span class="p">(</span><span class="n">Nel</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="s">"hello"</span><span class="p">).</span><span class="n">some</span><span class="p">())</span>
<span class="c1">// Tuple2(a=None, b=Some(hello))</span>
</code></pre></div></div>

<p>As you can see, since we cannot modify the immutable Stack, we need to create a new instance every time we push or pop values from it. For that same reason we have to return the newly created Stack with every operation.</p>

<p>However, it is a bit cumbersome to explicitly pass around all of this intermediate state. It’s also a bit error-prone. It would have been easy to accidentally return <code class="highlighter-rouge">pop(s1)</code>, for example.</p>

<h2 id="cleaning-it-up-with-state">Cleaning it up with State</h2>

<p>State’s special power is keeping track of state and passing it along. Recall the description of <code class="highlighter-rouge">State</code> at the beginning of this document. It is basically a function <code class="highlighter-rouge">S -&gt; Tuple2(S, A)</code>, where <code class="highlighter-rouge">S</code> is a type representing state.</p>

<p>Our <code class="highlighter-rouge">pop</code> function takes a <code class="highlighter-rouge">Stack</code> and returns an updated <code class="highlighter-rouge">Stack</code> and a <code class="highlighter-rouge">String</code>. It can be represented as <code class="highlighter-rouge">Stack -&gt; Tuple2(Stack, String)</code>, and therefore matches the pattern <code class="highlighter-rouge">S -&gt; Tuple2(S, A)</code> where <code class="highlighter-rouge">S</code> is <code class="highlighter-rouge">Stack</code> and <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">String</code>.</p>

<p>Let’s write a new version of <code class="highlighter-rouge">pop</code> and <code class="highlighter-rouge">push</code> using <code class="highlighter-rouge">State</code>:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>

<span class="k">fun</span> <span class="n">pop</span><span class="p">()</span> <span class="p">=</span> <span class="n">State</span><span class="p">&lt;</span><span class="n">Stack</span><span class="p">,</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">{</span> <span class="n">stack</span> <span class="p">-&gt;</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">fold</span><span class="p">({</span>
        <span class="n">None</span> <span class="n">toT</span> <span class="n">None</span>
    <span class="p">},</span> <span class="p">{</span>
        <span class="n">Nel</span><span class="p">.</span><span class="n">fromList</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">tail</span><span class="p">)</span> <span class="n">toT</span> <span class="n">it</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">some</span><span class="p">()</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">=</span> <span class="n">State</span><span class="p">&lt;</span><span class="n">Stack</span><span class="p">,</span> <span class="n">Unit</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">stack</span> <span class="p">-&gt;</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">fold</span><span class="p">({</span>
        <span class="n">Nel</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">some</span><span class="p">()</span> <span class="n">toT</span> <span class="n">Unit</span>
    <span class="p">},</span> <span class="p">{</span>
        <span class="n">Nel</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">all</span><span class="p">).</span><span class="n">some</span><span class="p">()</span> <span class="n">toT</span> <span class="n">Unit</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">flatMap</code> method on <code class="highlighter-rouge">State&lt;S, A&gt;</code> lets you use the result of one <code class="highlighter-rouge">State</code> in a subsequent <code class="highlighter-rouge">State</code>. The updated state (<code class="highlighter-rouge">S</code>) after the first call is passed into the second call. These <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">map</code> methods allow us to use <code class="highlighter-rouge">State</code> in for-comprehensions:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.typeclasses.*</span>
<span class="k">import</span> <span class="nn">arrow.instances.*</span>

<span class="k">fun</span> <span class="n">stackOperations</span><span class="p">()</span> <span class="p">=</span> <span class="n">State</span><span class="p">().</span><span class="n">monad</span><span class="p">&lt;</span><span class="n">Stack</span><span class="p">&gt;().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">push</span><span class="p">(</span><span class="s">"a"</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">b</span> <span class="p">=</span> <span class="n">pop</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">c</span> <span class="p">=</span> <span class="n">pop</span><span class="p">().</span><span class="n">bind</span><span class="p">()</span>

    <span class="n">c</span>
<span class="p">}.</span><span class="n">fix</span><span class="p">()</span>
</code></pre></div></div>

<p>At this point, we have not yet interacted with any Stack; we have written instructions to operate one. We need to pass in an initial stack value, and then we actually apply our operations to it:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stackOperations</span><span class="p">().</span><span class="n">run</span><span class="p">(</span><span class="n">Nel</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="s">"!"</span><span class="p">).</span><span class="n">some</span><span class="p">())</span>
<span class="c1">// Tuple2(a=Some(NonEmptyList(all=[world, !])), b=Some(hello))</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stackOperations</span><span class="p">().</span><span class="n">run</span><span class="p">(</span><span class="n">Nel</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="s">"hello"</span><span class="p">).</span><span class="n">some</span><span class="p">())</span>
<span class="c1">// Tuple2(a=None, b=Some(hello))</span>
</code></pre></div></div>

<p>If we only care about the resulting String and not the final state, then we can use <code class="highlighter-rouge">runA</code>:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stackOperations</span><span class="p">().</span><span class="n">runA</span><span class="p">(</span><span class="n">Nel</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="s">"!"</span><span class="p">).</span><span class="n">some</span><span class="p">())</span>
<span class="c1">// Some(hello)</span>
</code></pre></div></div>

<h2 id="available-instances">Available Instances</h2>

<ul>
  <li><a href="/docs/typeclasses/applicative">Applicative</a></li>
  <li><a href="/docs/typeclasses/functor">Functor</a></li>
  <li><a href="/docs/typeclasses/monad">Monad</a></li>
  <li><a href="/docs/typeclasses/monadstate">MonadState</a></li>
</ul>

<h2 id="credits">Credits</h2>

<p>Contents partially adapted from <a href="https://typelevel.org/cats/datatypes/state.html">Cats State</a></p>
