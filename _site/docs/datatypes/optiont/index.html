<h2 id="optiont">OptionT</h2>

<p><code class="highlighter-rouge">OptionT</code> also known as the <code class="highlighter-rouge">Option</code> monad transformer allows to compute inside the context when <code class="highlighter-rouge">Option</code> is nested in a different monad.</p>

<p>One issue we face with monads is that they don’t compose. This can cause your code to get really hairy when trying to combine structures like <code class="highlighter-rouge">ObservableK</code> and <code class="highlighter-rouge">Option</code>. But there’s a simple solution, and we’re going to explain how you can use Monad Transformers to alleviate this problem.</p>

<p>For our purposes here, we’re going to utilize a monad that serves as a container that may hold a value and where a computation can be performed.</p>

<p>Given that both <code class="highlighter-rouge">ObservableK&lt;A&gt;</code> and <code class="highlighter-rouge">Option&lt;A&gt;</code> would be examples of datatypes that provide instances for the <code class="highlighter-rouge">Monad</code> typeclasses.</p>

<p>Because <a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose/">monads don’t compose</a>, we may end up with nested structures such as <code class="highlighter-rouge">ObservableK&lt;Option&lt;ObservableK&lt;Option&lt;A&gt;&gt;&gt;</code> when using <code class="highlighter-rouge">ObservableK</code> and <code class="highlighter-rouge">Option</code> together. Using Monad Transformers can help us to reduce this boilerplate.</p>

<p>In the most basic of scenarios, we’ll only be dealing with one monad at a time making our lives nice and easy. However, it’s not uncommon to get into scenarios where some function calls will return <code class="highlighter-rouge">ObservableK&lt;A&gt;</code>, and others will return <code class="highlighter-rouge">Option&lt;A&gt;</code>.</p>

<p>So let’s test this out with an example:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>
<span class="k">import</span> <span class="nn">arrow.core.*</span>

<span class="kd">data class</span> <span class="nc">Country</span><span class="p">(</span><span class="kd">val</span> <span class="py">code</span><span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span>
<span class="kd">data class</span> <span class="nc">Address</span><span class="p">(</span><span class="kd">val</span> <span class="py">id</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="kd">val</span> <span class="py">country</span><span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Country</span><span class="p">&gt;)</span>
<span class="kd">data class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">address</span><span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Address</span><span class="p">&gt;)</span>

<span class="k">fun</span> <span class="n">getCountryCode</span><span class="p">(</span><span class="n">maybePerson</span> <span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">maybePerson</span><span class="p">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">person</span> <span class="p">-&gt;</span>
    <span class="n">person</span><span class="p">.</span><span class="n">address</span><span class="p">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">address</span> <span class="p">-&gt;</span>
      <span class="n">address</span><span class="p">.</span><span class="n">country</span><span class="p">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">country</span> <span class="p">-&gt;</span>
        <span class="n">country</span><span class="p">.</span><span class="n">code</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Nested flatMap calls flatten the <code class="highlighter-rouge">Option</code> but the resulting function starts looking like a pyramid and can easily lead to callback hell.</p>

<p>We can further simplify this case by using Arrow <code class="highlighter-rouge">binding</code> facilities
that enables monad comprehensions for all datatypes for which a monad instance is available.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.typeclasses.*</span>

<span class="k">fun</span> <span class="n">getCountryCode</span><span class="p">(</span><span class="n">maybePerson</span> <span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;):</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">Option</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">person</span> <span class="p">=</span> <span class="n">maybePerson</span><span class="p">.</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">address</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">address</span><span class="p">.</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">country</span> <span class="p">=</span> <span class="n">address</span><span class="p">.</span><span class="n">country</span><span class="p">.</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">code</span> <span class="p">=</span> <span class="n">country</span><span class="p">.</span><span class="n">code</span><span class="p">.</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">code</span>
  <span class="p">}.</span><span class="n">fix</span><span class="p">()</span>
</code></pre></div></div>

<p>Alright, a piece of cake right? That’s because we were dealing with a simple type <code class="highlighter-rouge">Option</code>. But here’s where things can get more complicated. Let’s introduce another monad in the middle of the computation. For example what happens when we need to load a person by id, then their address and country to obtain the country code from a remote service?</p>

<p>Consider this simple database representation:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">personDB</span><span class="p">:</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">Person</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">mapOf</span><span class="p">(</span>
  <span class="m">1</span> <span class="n">to</span> <span class="n">Person</span><span class="p">(</span>
        <span class="n">name</span> <span class="p">=</span> <span class="s">"Alfredo Lambda"</span><span class="p">,</span>
        <span class="n">address</span> <span class="p">=</span> <span class="n">Some</span><span class="p">(</span>
          <span class="n">Address</span><span class="p">(</span>
            <span class="n">id</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span>
            <span class="n">country</span> <span class="p">=</span> <span class="n">Some</span><span class="p">(</span>
              <span class="n">Country</span><span class="p">(</span>
                <span class="n">code</span> <span class="p">=</span> <span class="n">Some</span><span class="p">(</span><span class="s">"ES"</span><span class="p">)</span>
              <span class="p">)</span>
            <span class="p">)</span>
          <span class="p">)</span>
        <span class="p">)</span>
      <span class="p">)</span>
<span class="p">)</span>

<span class="kd">val</span> <span class="py">adressDB</span><span class="p">:</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">Address</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">mapOf</span><span class="p">(</span>
  <span class="m">1</span> <span class="n">to</span> <span class="n">Address</span><span class="p">(</span>
    <span class="n">id</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span>
    <span class="n">country</span> <span class="p">=</span> <span class="n">Some</span><span class="p">(</span>
      <span class="n">Country</span><span class="p">(</span>
        <span class="n">code</span> <span class="p">=</span> <span class="n">Some</span><span class="p">(</span><span class="s">"ES"</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="p">)</span>
  <span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Now we’ve got two new functions in the mix that are going to call a remote service, and they return a <code class="highlighter-rouge">ObservableK</code>. This is common in most APIs that handle loading asynchronously.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.effects.*</span>

<span class="k">fun</span> <span class="n">findPerson</span><span class="p">(</span><span class="n">personId</span> <span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">ObservableK</span><span class="p">&lt;</span><span class="n">Option</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
  <span class="n">ObservableK</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="n">Option</span><span class="p">.</span><span class="n">fromNullable</span><span class="p">(</span><span class="n">personDB</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">personId</span><span class="p">)))</span> <span class="c1">//mock impl for simplicity</span>

<span class="k">fun</span> <span class="n">findCountry</span><span class="p">(</span><span class="n">addressId</span> <span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">ObservableK</span><span class="p">&lt;</span><span class="n">Option</span><span class="p">&lt;</span><span class="n">Country</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
  <span class="n">ObservableK</span><span class="p">.</span><span class="n">just</span><span class="p">(</span>
    <span class="n">Option</span><span class="p">.</span><span class="n">fromNullable</span><span class="p">(</span><span class="n">adressDB</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">addressId</span><span class="p">)).</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">country</span> <span class="p">}</span>
  <span class="p">)</span> <span class="c1">//mock impl for simplicity</span>

</code></pre></div></div>

<p>A naive implementation attempt to get to a <code class="highlighter-rouge">country.code</code> from a <code class="highlighter-rouge">person.id</code> might look something like this.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">getCountryCode</span><span class="p">(</span><span class="n">personId</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">=</span>
  <span class="n">findPerson</span><span class="p">(</span><span class="n">personId</span><span class="p">).</span><span class="n">map</span> <span class="p">{</span> <span class="n">maybePerson</span> <span class="p">-&gt;</span>
    <span class="n">maybePerson</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">person</span> <span class="p">-&gt;</span>
      <span class="n">person</span><span class="p">.</span><span class="n">address</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">address</span> <span class="p">-&gt;</span>
        <span class="n">findCountry</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">).</span><span class="n">map</span> <span class="p">{</span> <span class="n">maybeCountry</span> <span class="p">-&gt;</span>
          <span class="n">maybeCountry</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">country</span> <span class="p">-&gt;</span>
            <span class="n">country</span><span class="p">.</span><span class="n">code</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>  
    <span class="p">}</span>
  <span class="p">}</span>

<span class="kd">val</span> <span class="py">lifted</span> <span class="p">=</span> <span class="p">{</span> <span class="n">personId</span><span class="p">:</span> <span class="n">Int</span> <span class="p">-&gt;</span> <span class="n">getCountryCode</span><span class="p">(</span><span class="n">personId</span><span class="p">)</span> <span class="p">}</span>
<span class="n">lifted</span>
<span class="c1">// (kotlin.Int) -&gt; arrow.effects.ObservableK&lt;arrow.core.Option&lt;arrow.core.Option&lt;arrow.effects.ObservableK&lt;arrow.core.Option&lt;arrow.core.Option&lt;kotlin.String&gt;&gt;&gt;&gt;&gt;&gt;</span>
</code></pre></div></div>

<p>This isn’t actually what we want since the inferred return type is <code class="highlighter-rouge">ObservableK&lt;Option&lt;Option&lt;ObservableK&lt;Option&lt;Option&lt;String&gt;&gt;&gt;&gt;&gt;&gt;</code>. We can’t use flatMap in this case because the nested expression does not match the return type of the expression they’re contained within. This is because we’re not flatMapping properly over the nested types.</p>

<p>Still not ideal. The levels of nesting are pyramidal with <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">map</code> and are as deep as the number of operations that you have to perform.</p>

<p>Let’s look at how a similar implementation would look like using monad comprehensions without transformers:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">getCountryCode</span><span class="p">(</span><span class="n">personId</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">ObservableK</span><span class="p">&lt;</span><span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
      <span class="n">ObservableK</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
        <span class="kd">val</span> <span class="py">maybePerson</span> <span class="p">=</span> <span class="n">findPerson</span><span class="p">(</span><span class="n">personId</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
        <span class="kd">val</span> <span class="py">person</span> <span class="p">=</span> <span class="n">maybePerson</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span>
          <span class="p">{</span> <span class="n">ObservableK</span><span class="p">.</span><span class="n">raiseError</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;(</span><span class="n">NoSuchElementException</span><span class="p">(</span><span class="s">"..."</span><span class="p">))</span> <span class="p">},</span>
          <span class="p">{</span> <span class="n">ObservableK</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">).</span><span class="n">bind</span><span class="p">()</span>
        <span class="kd">val</span> <span class="py">address</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">address</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span>
          <span class="p">{</span> <span class="n">ObservableK</span><span class="p">.</span><span class="n">raiseError</span><span class="p">&lt;</span><span class="n">Address</span><span class="p">&gt;(</span><span class="n">NoSuchElementException</span><span class="p">(</span><span class="s">"..."</span><span class="p">))</span> <span class="p">},</span>
          <span class="p">{</span> <span class="n">ObservableK</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">).</span><span class="n">bind</span><span class="p">()</span>
        <span class="kd">val</span> <span class="py">maybeCountry</span> <span class="p">=</span> <span class="n">findCountry</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
        <span class="kd">val</span> <span class="py">country</span> <span class="p">=</span> <span class="n">maybeCountry</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span>
          <span class="p">{</span> <span class="n">ObservableK</span><span class="p">.</span><span class="n">raiseError</span><span class="p">&lt;</span><span class="n">Country</span><span class="p">&gt;(</span><span class="n">NoSuchElementException</span><span class="p">(</span><span class="s">"..."</span><span class="p">))</span> <span class="p">},</span>
          <span class="p">{</span> <span class="n">ObservableK</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">).</span><span class="n">bind</span><span class="p">()</span>
        <span class="n">country</span><span class="p">.</span><span class="n">code</span>
      <span class="p">}.</span><span class="n">fix</span><span class="p">()</span>
</code></pre></div></div>

<p>While we’ve got the logic working now, we’re in a situation where we’re forced to deal with the <code class="highlighter-rouge">None cases</code>. We also have a ton of boilerplate type conversion with <code class="highlighter-rouge">fold</code>. The type conversion is necessary because in a monad comprehension you can only use a type of Monad. If we start with <code class="highlighter-rouge">ObservableK</code>, we have to stay in it’s monadic context by lifting anything we compute sequentially to a <code class="highlighter-rouge">ObservableK</code> whether or not it’s async.</p>

<p>This is a commonly encountered problem, especially in the context of async services. So how can we reconcile the fact that we’re mixing <code class="highlighter-rouge">Option</code> and <code class="highlighter-rouge">ObservableK</code>?</p>

<h3 id="monad-transformers-to-the-rescue">Monad Transformers to the Rescue!</h3>

<p>Monad Transformers enable you to combine two monads into a super monad. In this case, we’re going to use <code class="highlighter-rouge">OptionT</code>
from Arrow to express the effect of potential absence inside our async computations.</p>

<p><code class="highlighter-rouge">OptionT</code> has the form of <code class="highlighter-rouge">OptionT&lt;F, A&gt;</code>.</p>

<p>This means that for any monad <code class="highlighter-rouge">F</code> surrounding an <code class="highlighter-rouge">Option&lt;A&gt;</code> we can obtain an <code class="highlighter-rouge">OptionT&lt;F, A&gt;</code>.
So our specialization <code class="highlighter-rouge">OptionT&lt;ForObservableK, A&gt;</code> is the OptionT transformer around values that are of <code class="highlighter-rouge">ObservableK&lt;Option&lt;A&gt;&gt;</code>.</p>

<p>We can now lift any value to a <code class="highlighter-rouge">OptionT&lt;F, A&gt;</code> which looks like this:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.data.*</span>

<span class="kd">val</span> <span class="py">optTVal</span> <span class="p">=</span> <span class="n">OptionT</span><span class="p">.</span><span class="n">just</span><span class="p">&lt;</span><span class="n">ForObservableK</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;(</span><span class="n">ObservableK</span><span class="p">.</span><span class="n">applicative</span><span class="p">(),</span> <span class="m">1</span><span class="p">)</span>
<span class="n">optTVal</span>
<span class="c1">// OptionT(value=ObservableK(observable=io.reactivex.internal.operators.observable.ObservableJust@57b9d6de))</span>
</code></pre></div></div>

<p>or</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">optTVal</span> <span class="p">=</span> <span class="n">OptionT</span><span class="p">.</span><span class="n">fromOption</span><span class="p">&lt;</span><span class="n">ForObservableK</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;(</span><span class="n">ObservableK</span><span class="p">.</span><span class="n">applicative</span><span class="p">(),</span> <span class="n">Some</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
<span class="n">optTVal</span>
<span class="c1">// OptionT(value=ObservableK(observable=io.reactivex.internal.operators.observable.ObservableJust@4eaa7133))</span>
</code></pre></div></div>

<p>And back to the <code class="highlighter-rouge">ObservableK&lt;Option&lt;A&gt;&gt;</code> running the transformer</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optTVal</span><span class="p">.</span><span class="n">value</span><span class="p">()</span>
<span class="c1">// ObservableK(observable=io.reactivex.internal.operators.observable.ObservableJust@4eaa7133)</span>
</code></pre></div></div>

<p>So how would our function look if we implemented it with the OptionT monad transformer?</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">getCountryCode</span><span class="p">(</span><span class="n">personId</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">ObservableK</span><span class="p">&lt;</span><span class="n">Option</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;</span> <span class="p">=</span>
  <span class="n">OptionT</span><span class="p">.</span><span class="n">monad</span><span class="p">&lt;</span><span class="n">ForObservableK</span><span class="p">&gt;().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">person</span> <span class="p">=</span> <span class="n">OptionT</span><span class="p">(</span><span class="n">findPerson</span><span class="p">(</span><span class="n">personId</span><span class="p">)).</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">address</span> <span class="p">=</span> <span class="n">OptionT</span><span class="p">(</span><span class="n">ObservableK</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">address</span><span class="p">)).</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">country</span> <span class="p">=</span> <span class="n">OptionT</span><span class="p">(</span><span class="n">findCountry</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)).</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">code</span> <span class="p">=</span> <span class="n">OptionT</span><span class="p">(</span><span class="n">ObservableK</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="n">country</span><span class="p">.</span><span class="n">code</span><span class="p">)).</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">code</span>
  <span class="p">}.</span><span class="n">value</span><span class="p">().</span><span class="n">fix</span><span class="p">()</span>
</code></pre></div></div>

<p>Here we no longer have to deal with the <code class="highlighter-rouge">None</code> cases, and the binding to the values on the left side are already the underlying values we want to focus on instead of the optional values. We have automatically <code class="highlighter-rouge">flatMapped</code> through the <code class="highlighter-rouge">ObservableK</code> and <code class="highlighter-rouge">Option</code> in a single expression reducing the boilerplate and encoding the effects concerns in the type signatures.</p>

<h2 id="available-instances">Available Instances</h2>

<ul>
  <li><a href="/docs/typeclasses/applicative">Applicative</a></li>
  <li><a href="/docs/typeclasses/foldable">Foldable</a></li>
  <li><a href="/docs/typeclasses/functor">Functor</a></li>
  <li><a href="/docs/typeclasses/monad">Monad</a></li>
  <li><a href="/docs/typeclasses/monoidk">MonoidK</a></li>
  <li><a href="/docs/typeclasses/semigroupk">SemigroupK</a></li>
  <li><a href="/docs/typeclasses/traverse">Traverse</a></li>
</ul>

<p>Take a look at the <a href="/docs/datatypes/eithert"><code class="highlighter-rouge">EitherT</code> docs</a> for an alternative version of this content with the <code class="highlighter-rouge">EitherT</code> monad transformer</p>

<h2 id="credits">Credits</h2>

<p>Contents partially adapted from <a href="https://www.47deg.com/blog/fp-for-the-average-joe-part-2-scalaz-monad-transformers/">FP for the avg Joe at the 47 Degrees blog</a></p>
