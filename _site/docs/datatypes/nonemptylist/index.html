<h2 id="nonemptylist">NonEmptyList</h2>

<p><code class="highlighter-rouge">NonEmptyList</code> is a data type used in <strong>Λrrow</strong> to model ordered lists that guarantee to have at least one value.
<code class="highlighter-rouge">NonEmptyList</code> is available in the <code class="highlighter-rouge">arrow-data</code> module under the <code class="highlighter-rouge">import arrow.data.NonEmptyList</code></p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// gradle</span>
<span class="n">compile</span> <span class="s1">'io.arrow-kt:arrow-data:$arrowVersion'</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// namespace</span>
<span class="k">import</span> <span class="nn">arrow.data.NonEmptyList</span>
</code></pre></div></div>

<h2 id="of">of</h2>

<p>A <code class="highlighter-rouge">NonEmptyList</code> guarantees the list always has at least 1 element.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span> <span class="c1">// NonEmptyList&lt;Int&gt;</span>
<span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="c1">// NonEmptyList&lt;Int&gt;</span>
<span class="c1">//NonEmptyList.of() // does not compile</span>
</code></pre></div></div>

<h2 id="head">head</h2>

<p>Unlike <code class="highlighter-rouge">List#[0]</code>, <code class="highlighter-rouge">NonEmptyList#head</code> it’s a safe operation that guarantees no exception throwing.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">).</span><span class="n">head</span>
</code></pre></div></div>

<h2 id="foldleft">foldLeft</h2>

<p>When we fold over a <code class="highlighter-rouge">NonEmptyList</code>, we turn a <code class="highlighter-rouge">NonEmptyList&lt; A &gt;</code> into <code class="highlighter-rouge">B</code> by providing a <strong>seed</strong> value and a <strong>function</strong> that carries the state on each iteration over the elements of the list.
The first argument is a function that addresses the <strong>seed value</strong>, this can be any object of any type which will then become the resulting typed value.
The second argument is a function that takes the current state and element in the iteration and returns the new state after transformations have been applied.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">sumNel</span><span class="p">(</span><span class="n">nel</span><span class="p">:</span> <span class="n">NonEmptyList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;):</span> <span class="n">Int</span> <span class="p">=</span>
  <span class="n">nel</span><span class="p">.</span><span class="n">foldLeft</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">acc</span><span class="p">,</span> <span class="n">n</span> <span class="p">-&gt;</span> <span class="n">acc</span> <span class="p">+</span> <span class="n">n</span> <span class="p">}</span>

<span class="n">sumNel</span><span class="p">(</span><span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span>
<span class="c1">// 4</span>
</code></pre></div></div>

<h2 id="map">map</h2>

<p><code class="highlighter-rouge">map</code> allows us to transform <code class="highlighter-rouge">A</code> into <code class="highlighter-rouge">B</code> in <code class="highlighter-rouge">NonEmptyList&lt; A &gt;</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">).</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">+</span> <span class="m">1</span> <span class="p">}</span>
<span class="c1">// NonEmptyList(all=[2, 2, 2, 2])</span>
</code></pre></div></div>

<h2 id="flatmap">flatMap</h2>

<p><code class="highlighter-rouge">flatMap</code> allows us to compute over the contents of multiple <code class="highlighter-rouge">NonEmptyList&lt; * &gt;</code> values</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">nelOne</span><span class="p">:</span> <span class="n">NonEmptyList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
<span class="kd">val</span> <span class="py">nelTwo</span><span class="p">:</span> <span class="n">NonEmptyList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>

<span class="n">nelOne</span><span class="p">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">one</span> <span class="p">-&gt;</span>
  <span class="n">nelTwo</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">two</span> <span class="p">-&gt;</span>
    <span class="n">one</span> <span class="p">+</span> <span class="n">two</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// NonEmptyList(all=[3])</span>
</code></pre></div></div>

<h2 id="monad-binding">Monad binding</h2>

<p>Λrrow allows imperative style comprehensions to make computing over <code class="highlighter-rouge">NonEmptyList</code> values easy.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">nelOne</span><span class="p">:</span> <span class="n">NonEmptyList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
<span class="kd">val</span> <span class="py">nelTwo</span><span class="p">:</span> <span class="n">NonEmptyList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
<span class="kd">val</span> <span class="py">nelThree</span><span class="p">:</span> <span class="n">NonEmptyList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>

<span class="n">NonEmptyList</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">one</span> <span class="p">=</span> <span class="n">nelOne</span><span class="p">.</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">two</span> <span class="p">=</span> <span class="n">nelTwo</span><span class="p">.</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">three</span> <span class="p">=</span> <span class="n">nelThree</span><span class="p">.</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">yields</span><span class="p">(</span><span class="n">one</span> <span class="p">+</span> <span class="n">two</span> <span class="p">+</span> <span class="n">three</span><span class="p">)</span>
<span class="p">}.</span><span class="n">ev</span><span class="p">()</span>
<span class="c1">// NonEmptyList(6)</span>
</code></pre></div></div>

<p>Monad binding in <code class="highlighter-rouge">NonEmptyList</code> and other collection related data type can be used as generators</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NonEmptyList</span><span class="p">.</span><span class="n">monad</span><span class="p">().</span><span class="n">binding</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">x</span> <span class="p">=</span> <span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">y</span> <span class="p">=</span> <span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">).</span><span class="n">bind</span><span class="p">()</span>
    <span class="n">yields</span><span class="p">(</span><span class="n">x</span> <span class="p">+</span> <span class="n">y</span><span class="p">)</span>
<span class="p">}.</span><span class="n">ev</span><span class="p">()</span>
<span class="c1">// NonEmptyList(all=[2, 3, 4, 3, 4, 5, 4, 5, 6])</span>
</code></pre></div></div>

<h2 id="applicative-builder">Applicative Builder</h2>

<p>Λrrow contains methods that allow you to preserve type information when computing over different <code class="highlighter-rouge">NonEmptyList</code> typed values.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.data.*</span>
<span class="k">import</span> <span class="nn">java.util.*</span>

<span class="kd">data class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">id</span><span class="p">:</span> <span class="n">UUID</span><span class="p">,</span> <span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">year</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>

<span class="c1">// Note each NonEmptyList is of a different type</span>
<span class="kd">val</span> <span class="py">nelId</span><span class="p">:</span> <span class="n">NonEmptyList</span><span class="p">&lt;</span><span class="n">UUID</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">UUID</span><span class="p">.</span><span class="n">randomUUID</span><span class="p">(),</span> <span class="n">UUID</span><span class="p">.</span><span class="n">randomUUID</span><span class="p">())</span>
<span class="kd">val</span> <span class="py">nelName</span><span class="p">:</span> <span class="n">NonEmptyList</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="s">"William Alvin Howard"</span><span class="p">,</span> <span class="s">"Haskell Curry"</span><span class="p">)</span>
<span class="kd">val</span> <span class="py">nelYear</span><span class="p">:</span> <span class="n">NonEmptyList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">NonEmptyList</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="m">1926</span><span class="p">,</span> <span class="m">1900</span><span class="p">)</span>

<span class="n">NonEmptyList</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">nelId</span><span class="p">,</span> <span class="n">nelName</span><span class="p">,</span> <span class="n">nelYear</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span> <span class="p">-&gt;</span>
  <span class="n">Person</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span>
<span class="p">})</span>
<span class="c1">// NonEmptyList(all=[Person(id=b7561f01-0a8b-4f30-996a-3c67703ced8b, name=William Alvin Howard, year=1926), Person(id=b7561f01-0a8b-4f30-996a-3c67703ced8b, name=Haskell Curry, year=1926), Person(id=c7688861-57f1-4666-97d8-3ab17700073c, name=William Alvin Howard, year=1926), Person(id=c7688861-57f1-4666-97d8-3ab17700073c, name=Haskell Curry, year=1926), Person(id=b7561f01-0a8b-4f30-996a-3c67703ced8b, name=William Alvin Howard, year=1900), Person(id=b7561f01-0a8b-4f30-996a-3c67703ced8b, name=Haskell Curry, year=1900), Person(id=c7688861-57f1-4666-97d8-3ab17700073c, name=William Alvin Howard, year=1900), Person(id=c7688861-57f1-4666-97d8-3ab17700073c, name=Haskell Curry, year=1900)])</span>
</code></pre></div></div>

<h3 id="summary">Summary</h3>

<ul>
  <li><code class="highlighter-rouge">NonEmptyList</code> is <strong>used to model lists that guarantee at least one element</strong></li>
  <li>We can easily construct values of <code class="highlighter-rouge">NonEmptyList</code> with <code class="highlighter-rouge">NonEmptyList.of</code></li>
  <li><code class="highlighter-rouge">foldLeft</code>, <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code> and others are used to compute over the internal contents of a <code class="highlighter-rouge">NonEmptyList</code> value.</li>
  <li><code class="highlighter-rouge">NonEmptyList.monad().binding { ... } Comprehensions</code> can be <strong>used to imperatively compute</strong> over multiple <code class="highlighter-rouge">NonEmptyList</code> values in sequence.</li>
  <li><code class="highlighter-rouge">NonEmptyList.applicative().map { ... }</code> can be used to compute over multiple <code class="highlighter-rouge">NonEmptyList</code> values preserving type information and <strong>abstracting over arity</strong> with <code class="highlighter-rouge">map</code></li>
</ul>

<h2 id="available-instances">Available Instances</h2>

<ul>
  <li><a href="/docs/typeclasses/show">Show</a></li>
  <li><a href="/docs/typeclasses/eq">Eq</a></li>
  <li><a href="/docs/typeclasses/applicative">Applicative</a></li>
  <li><a href="/docs/typeclasses/bimonad">Bimonad</a></li>
  <li><a href="/docs/typeclasses/comonad">Comonad</a></li>
  <li><a href="/docs/typeclasses/foldable">Foldable</a></li>
  <li><a href="/docs/typeclasses/functor">Functor</a></li>
  <li><a href="/docs/typeclasses/monad">Monad</a></li>
  <li><a href="/docs/typeclasses/semigroup">Semigroup</a></li>
  <li><a href="/docs/typeclasses/semigroupk">SemigroupK</a></li>
  <li><a href="/docs/typeclasses/traverse">Traverse</a></li>
  <li><a href="/docs/optics/index">Index</a></li>
  <li><a href="/docs/optics/filterindex">FilterIndex</a></li>
</ul>
