<h2 id="eval">Eval</h2>

<p>Eval is a monad that allows us to control evaluation and chain lazy operations that are not executed until <code class="highlighter-rouge">value()</code> is invoked.</p>

<p>Eval includes internally trampolining facilities which allows us to chain computations without fear of blowing up the stack.
There are two different factors that play into evaluation: memoization and laziness.</p>

<p>Eval supports memoization, eager and lazy evaluation strategies</p>

<h3 id="now">now</h3>

<p><code class="highlighter-rouge">Eval#now</code> creates an Eval instance from an already constructed value but still defers evaluation when chaining expressions with <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.*</span>
<span class="k">import</span> <span class="nn">arrow.core.*</span>

<span class="kd">val</span> <span class="py">eager</span> <span class="p">=</span> <span class="n">Eval</span><span class="p">.</span><span class="n">now</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">+</span> <span class="m">1</span> <span class="p">}</span>
<span class="n">eager</span><span class="p">.</span><span class="n">value</span><span class="p">()</span>
<span class="c1">// 2</span>
</code></pre></div></div>

<h3 id="later">later</h3>

<p><code class="highlighter-rouge">Eval#later</code> creates an Eval instance from a function deferring it’s evaluation until <code class="highlighter-rouge">.value()</code> is invoked memoizing the computed value.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">lazyEvaled</span> <span class="p">=</span> <span class="n">Eval</span><span class="p">.</span><span class="n">later</span> <span class="p">{</span> <span class="s">"expensive computation"</span> <span class="p">}</span>
<span class="n">lazyEvaled</span><span class="p">.</span><span class="n">value</span><span class="p">()</span>
<span class="c1">// expensive computation</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">"expensive computation"</code> is only computed once since the results are memoized and multiple calls to <code class="highlighter-rouge">value()</code> will just return the cached value.</p>

<h3 id="always">always</h3>

<p><code class="highlighter-rouge">Eval#always</code> creates an Eval instance from a function deferring it’s evaluation until <code class="highlighter-rouge">.value()</code> is invoked recomputing each time <code class="highlighter-rouge">.value()</code> is invoked.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">alwaysEvaled</span> <span class="p">=</span> <span class="n">Eval</span><span class="p">.</span><span class="n">always</span> <span class="p">{</span> <span class="s">"expensive computation"</span> <span class="p">}</span>
<span class="n">alwaysEvaled</span><span class="p">.</span><span class="n">value</span><span class="p">()</span>
<span class="c1">// expensive computation</span>
</code></pre></div></div>

<h3 id="stack-safety">Stack safety</h3>

<p><code class="highlighter-rouge">Eval</code> empowers stack safe programs by chaining lazy computations</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="n">even</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Eval</span><span class="p">&lt;</span><span class="n">Boolean</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">Eval</span><span class="p">.</span><span class="n">always</span> <span class="p">{</span> <span class="n">n</span> <span class="p">==</span> <span class="m">0</span> <span class="p">}.</span><span class="n">flatMap</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">it</span> <span class="p">==</span> <span class="k">true</span><span class="p">)</span> <span class="n">Eval</span><span class="p">.</span><span class="n">now</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="k">else</span> <span class="n">odd</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span>
  <span class="p">}</span>

<span class="k">fun</span> <span class="n">odd</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Eval</span><span class="p">&lt;</span><span class="n">Boolean</span><span class="p">&gt;</span> <span class="p">=</span>
  <span class="n">Eval</span><span class="p">.</span><span class="n">always</span> <span class="p">{</span> <span class="n">n</span> <span class="p">==</span> <span class="m">0</span> <span class="p">}.</span><span class="n">flatMap</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">it</span> <span class="p">==</span> <span class="k">true</span><span class="p">)</span> <span class="n">Eval</span><span class="p">.</span><span class="n">now</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
    <span class="k">else</span> <span class="n">even</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span>
  <span class="p">}</span>

<span class="c1">// if not wrapped in eval this type of computation would blow the stack and result in a StackOverflowError</span>
<span class="n">odd</span><span class="p">(</span><span class="m">100000</span><span class="p">).</span><span class="n">value</span><span class="p">()</span>
<span class="c1">// false</span>
</code></pre></div></div>

<h2 id="available-instances">Available Instances</h2>

<ul>
  <li><a href="/docs/typeclasses/applicative">Applicative</a></li>
  <li><a href="/docs/typeclasses/bimonad">Bimonad</a></li>
  <li><a href="/docs/typeclasses/comonad">Comonad</a></li>
  <li><a href="/docs/typeclasses/functor">Functor</a></li>
  <li><a href="/docs/typeclasses/monad">Monad</a></li>
</ul>

<h2 id="credits">Credits</h2>

<p>Contents partially adapted from <a href="https://typelevel.org/cats/datatypes/eval.html">Cats Eval</a></p>
